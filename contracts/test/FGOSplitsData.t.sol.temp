// SPDX-License-Identifier: UNLICENSE
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../src/FGOAccessControl.sol";
import "../src/FGOSplitsData.sol";
import "../src/FGOLibrary.sol";
import "../src/FGOErrors.sol";
import "../src/TestToken.sol";

contract FGOSplitsDataTest is Test {
    FGOAccessControl public accessControl;
    FGOSplitsData public splitsData;
    TestToken public testToken1;
    TestToken public testToken2;
    TestToken public testToken3;

    address public admin = makeAddr("admin");
    address public designer1 = makeAddr("designer1");
    address public fulfiller1 = makeAddr("fulfiller1");
    address public unauthorizedUser = makeAddr("unauthorizedUser");

    uint256 public constant FULFILLER_SPLIT = 7500;
    uint256 public constant FULFILLER_BASE = 1000 * 10 ** 18;
    uint256 public constant WEI_AMOUNT = 1 * 10 ** 18;
    uint256 public constant EXCHANGE_RATE = 2000 * 10 ** 18;

    event SplitsSet(
        address currency,
        uint256 fulfillerSplit,
        uint256 fulfillerBase,
        uint8 printType
    );
    event CurrencyAdded(
        address indexed currency,
        uint256 weiAmount,
        uint256 rate
    );
    event CurrencyRemoved(address indexed currency);

    function setUp() public {
        vm.prank(admin);
        accessControl = new FGOAccessControl();

        vm.startPrank(admin);
        accessControl.addDesigner(designer1);
        accessControl.addFulfiller(fulfiller1);
        vm.stopPrank();

        splitsData = new FGOSplitsData(address(accessControl));

        testToken1 = new TestToken();
        testToken2 = new TestToken();
        testToken3 = new TestToken();
    }

    function test_SetSplits_AdminOnly() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.prank(admin);
        vm.expectEmit(true, false, false, true);
        emit SplitsSet(address(testToken1), FULFILLER_SPLIT, FULFILLER_BASE, 1);
        splitsData.setSplits(
            address(testToken1),
            FULFILLER_SPLIT,
            FULFILLER_BASE,
            1
        );

        assertEq(
            splitsData.getFulfillerSplit(address(testToken1), 1),
            FULFILLER_SPLIT
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            FULFILLER_BASE
        );
    }

    function test_SetSplits_RevertIfNotAdmin() public {
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.setSplits(
            address(testToken1),
            FULFILLER_SPLIT,
            FULFILLER_BASE,
            1
        );

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.setSplits(
            address(testToken1),
            FULFILLER_SPLIT,
            FULFILLER_BASE,
            1
        );
    }

    function test_SetSplits_MultiplePrintTypes() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.startPrank(admin);

        splitsData.setSplits(address(testToken1), 6000, FULFILLER_BASE, 0);
        splitsData.setSplits(address(testToken1), 7500, FULFILLER_BASE, 1);
        splitsData.setSplits(address(testToken1), 8000, FULFILLER_BASE, 2);

        vm.stopPrank();

        assertEq(splitsData.getFulfillerSplit(address(testToken1), 0), 6000);
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 7500);
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 2), 8000);

        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 0),
            FULFILLER_BASE
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            FULFILLER_BASE
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 2),
            FULFILLER_BASE
        );
    }

    function test_SetSplits_UpdateExistingSplits() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.startPrank(admin);

        splitsData.setSplits(address(testToken1), 5000, 500 * 10 ** 18, 1);
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 5000);
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            500 * 10 ** 18
        );

        splitsData.setSplits(address(testToken1), 7000, 1500 * 10 ** 18, 1);
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 7000);
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            1500 * 10 ** 18
        );

        vm.stopPrank();
    }

    function test_AddCurrency() public {
        vm.prank(admin);
        vm.expectEmit(true, false, false, true);
        emit CurrencyAdded(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        assertTrue(splitsData.getIsCurrency(address(testToken1)));
        assertEq(
            splitsData.getCurrencyRate(address(testToken1)),
            EXCHANGE_RATE
        );
        assertEq(splitsData.getCurrencyWei(address(testToken1)), WEI_AMOUNT);

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 1);
        assertEq(currencies[0], address(testToken1));
    }

    function test_AddCurrency_RevertIfNotAdmin() public {
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
    }

    function test_AddCurrency_RevertIfDuplicate() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.expectRevert(FGOErrors.ExistingCurrency.selector);
        splitsData.addCurrency(
            address(testToken1),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );

        vm.stopPrank();
    }

    function test_AddMultipleCurrencies() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(
            address(testToken2),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );
        splitsData.addCurrency(
            address(testToken3),
            WEI_AMOUNT * 3,
            EXCHANGE_RATE * 3
        );

        vm.stopPrank();

        assertTrue(splitsData.getIsCurrency(address(testToken1)));
        assertTrue(splitsData.getIsCurrency(address(testToken2)));
        assertTrue(splitsData.getIsCurrency(address(testToken3)));

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 3);

        assertEq(
            splitsData.getCurrencyRate(address(testToken1)),
            EXCHANGE_RATE
        );
        assertEq(
            splitsData.getCurrencyRate(address(testToken2)),
            EXCHANGE_RATE * 2
        );
        assertEq(
            splitsData.getCurrencyRate(address(testToken3)),
            EXCHANGE_RATE * 3
        );

        assertEq(splitsData.getCurrencyWei(address(testToken1)), WEI_AMOUNT);
        assertEq(
            splitsData.getCurrencyWei(address(testToken2)),
            WEI_AMOUNT * 2
        );
        assertEq(
            splitsData.getCurrencyWei(address(testToken3)),
            WEI_AMOUNT * 3
        );
    }

    function test_RemoveCurrency() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(
            address(testToken2),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );

        assertTrue(splitsData.getIsCurrency(address(testToken1)));
        assertTrue(splitsData.getIsCurrency(address(testToken2)));

        vm.expectEmit(true, false, false, false);
        emit CurrencyRemoved(address(testToken1));
        splitsData.removeCurrency(address(testToken1));

        vm.stopPrank();

        assertFalse(splitsData.getIsCurrency(address(testToken1)));
        assertTrue(splitsData.getIsCurrency(address(testToken2)));

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 1);
        assertEq(currencies[0], address(testToken2));

        assertEq(splitsData.getCurrencyRate(address(testToken1)), 0);
        assertEq(splitsData.getCurrencyWei(address(testToken1)), 0);
        assertEq(
            splitsData.getCurrencyRate(address(testToken2)),
            EXCHANGE_RATE * 2
        );
    }

    function test_RemoveCurrency_RevertIfNotAdmin() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.prank(designer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.removeCurrency(address(testToken1));

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.removeCurrency(address(testToken1));
    }

    function test_RemoveCurrency_RevertIfNotExists() public {
        vm.prank(admin);
        vm.expectRevert(FGOErrors.CurrencyDoesntExist.selector);
        splitsData.removeCurrency(address(testToken1));
    }

    function test_GetFulfillerSplit_NonExistentCurrency() public view {
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 0);
        assertEq(splitsData.getFulfillerBase(address(testToken1), 1), 0);
    }

    function test_GetFulfillerSplit_NonExistentPrintType() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.prank(admin);
        splitsData.setSplits(
            address(testToken1),
            FULFILLER_SPLIT,
            FULFILLER_BASE,
            1
        );

        assertEq(splitsData.getFulfillerSplit(address(testToken1), 5), 0);
        assertEq(splitsData.getFulfillerBase(address(testToken1), 5), 0);
    }

    function test_SetAccessControl() public {
        FGOAccessControl newAccessControl = new FGOAccessControl();

        vm.prank(admin);
        splitsData.setAccessControl(address(newAccessControl));

        assertEq(
            address(splitsData.accessControl()),
            address(newAccessControl)
        );
    }

    function test_SetAccessControl_RevertIfNotAdmin() public {
        FGOAccessControl newAccessControl = new FGOAccessControl();

        vm.prank(designer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        splitsData.setAccessControl(address(newAccessControl));
    }

    function test_ContractMetadata() public view {
        assertEq(splitsData.name(), "FGOSplitsData");
        assertEq(splitsData.symbol(), "PSD");
    }

    function test_CurrencyManagement_FullLifecycle() public {
        assertFalse(splitsData.getIsCurrency(address(testToken1)));

        address[] memory emptyCurrencies = splitsData.getAllCurrencies();
        assertEq(emptyCurrencies.length, 0);

        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        assertTrue(splitsData.getIsCurrency(address(testToken1)));
        assertEq(
            splitsData.getCurrencyRate(address(testToken1)),
            EXCHANGE_RATE
        );
        assertEq(splitsData.getCurrencyWei(address(testToken1)), WEI_AMOUNT);

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 1);

        vm.prank(admin);
        splitsData.removeCurrency(address(testToken1));

        assertFalse(splitsData.getIsCurrency(address(testToken1)));
        assertEq(splitsData.getCurrencyRate(address(testToken1)), 0);
        assertEq(splitsData.getCurrencyWei(address(testToken1)), 0);

        address[] memory finalCurrencies = splitsData.getAllCurrencies();
        assertEq(finalCurrencies.length, 0);
    }

    function test_SplitsConfiguration_MultipleCurrencies() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(
            address(testToken2),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );

        splitsData.setSplits(address(testToken1), 6000, 500 * 10 ** 18, 1);
        splitsData.setSplits(address(testToken2), 8000, 1500 * 10 ** 18, 1);

        splitsData.setSplits(address(testToken1), 7000, 750 * 10 ** 18, 2);
        splitsData.setSplits(address(testToken2), 9000, 2000 * 10 ** 18, 2);

        vm.stopPrank();

        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 6000);
        assertEq(splitsData.getFulfillerSplit(address(testToken2), 1), 8000);
        assertEq(splitsData.getFulfillerSplit(address(testToken1), 2), 7000);
        assertEq(splitsData.getFulfillerSplit(address(testToken2), 2), 9000);

        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            500 * 10 ** 18
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken2), 1),
            1500 * 10 ** 18
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 2),
            750 * 10 ** 18
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken2), 2),
            2000 * 10 ** 18
        );
    }

    function test_EdgeCases_ZeroValues() public {
        vm.startPrank(admin);

        // Use a new token that hasn't been added yet
        TestToken newToken = new TestToken();
        splitsData.addCurrency(address(newToken), 1, 1e12);

        assertTrue(splitsData.getIsCurrency(address(newToken)));
        assertEq(splitsData.getCurrencyRate(address(newToken)), 1e12);
        assertEq(splitsData.getCurrencyWei(address(newToken)), 1);

        splitsData.setSplits(address(newToken), 0, 0, 1);

        assertEq(splitsData.getFulfillerSplit(address(newToken), 1), 0);
        assertEq(splitsData.getFulfillerBase(address(newToken), 1), 0);

        vm.stopPrank();
    }

    function test_EdgeCases_MaxValues() public {
        vm.startPrank(admin);

        splitsData.addCurrency(
            address(testToken1),
            type(uint256).max,
            type(uint256).max
        );

        assertTrue(splitsData.getIsCurrency(address(testToken1)));
        assertEq(
            splitsData.getCurrencyRate(address(testToken1)),
            type(uint256).max
        );
        assertEq(
            splitsData.getCurrencyWei(address(testToken1)),
            type(uint256).max
        );

        splitsData.setSplits(
            address(testToken1),
            type(uint256).max,
            type(uint256).max,
            1
        );

        assertEq(
            splitsData.getFulfillerSplit(address(testToken1), 1),
            type(uint256).max
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            type(uint256).max
        );

        vm.stopPrank();
    }

    function test_PrintTypeRange() public {
        vm.prank(admin);
        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);

        vm.startPrank(admin);

        for (uint8 i = 0; i < 10; i++) {
            uint256 fulfillerSplit = FULFILLER_SPLIT + uint256(i) * 100;
            uint256 fulfillerBase = FULFILLER_BASE + uint256(i) * 10 ** 17;
            splitsData.setSplits(
                address(testToken1),
                fulfillerSplit,
                fulfillerBase,
                i
            );
        }

        vm.stopPrank();

        for (uint8 i = 0; i < 10; i++) {
            uint256 expectedSplit = FULFILLER_SPLIT + uint256(i) * 100;
            uint256 expectedBase = FULFILLER_BASE + uint256(i) * 10 ** 17;
            assertEq(
                splitsData.getFulfillerSplit(address(testToken1), i),
                expectedSplit
            );
            assertEq(
                splitsData.getFulfillerBase(address(testToken1), i),
                expectedBase
            );
        }
    }

    function test_CurrencyList_OrderPreservation() public {
        address[] memory expectedOrder = new address[](3);
        expectedOrder[0] = address(testToken1);
        expectedOrder[1] = address(testToken2);
        expectedOrder[2] = address(testToken3);

        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(
            address(testToken2),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );
        splitsData.addCurrency(
            address(testToken3),
            WEI_AMOUNT * 3,
            EXCHANGE_RATE * 3
        );

        vm.stopPrank();

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 3);

        bool foundToken1 = false;
        bool foundToken2 = false;
        bool foundToken3 = false;

        for (uint256 i = 0; i < currencies.length; i++) {
            if (currencies[i] == address(testToken1)) foundToken1 = true;
            if (currencies[i] == address(testToken2)) foundToken2 = true;
            if (currencies[i] == address(testToken3)) foundToken3 = true;
        }

        assertTrue(foundToken1);
        assertTrue(foundToken2);
        assertTrue(foundToken3);
    }

    function test_RemoveCurrency_DoesNotAffectSplits() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.setSplits(
            address(testToken1),
            FULFILLER_SPLIT,
            FULFILLER_BASE,
            1
        );

        assertEq(
            splitsData.getFulfillerSplit(address(testToken1), 1),
            FULFILLER_SPLIT
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            FULFILLER_BASE
        );

        splitsData.removeCurrency(address(testToken1));

        assertEq(
            splitsData.getFulfillerSplit(address(testToken1), 1),
            FULFILLER_SPLIT
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            FULFILLER_BASE
        );

        vm.stopPrank();
    }

    function test_CurrencyOperations_BatchScenario() public {
        address[] memory tokens = new address[](5);
        tokens[0] = address(testToken1);
        tokens[1] = address(testToken2);
        tokens[2] = address(testToken3);
        tokens[3] = makeAddr("token4");
        tokens[4] = makeAddr("token5");

        vm.startPrank(admin);

        for (uint256 i = 0; i < tokens.length; i++) {
            splitsData.addCurrency(
                tokens[i],
                WEI_AMOUNT * (i + 1),
                EXCHANGE_RATE * (i + 1)
            );
            splitsData.setSplits(
                tokens[i],
                FULFILLER_SPLIT + i * 500,
                FULFILLER_BASE + i * 100 * 10 ** 18,
                1
            );
        }

        address[] memory currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 5);

        for (uint256 i = 0; i < 3; i++) {
            splitsData.removeCurrency(tokens[i]);
        }

        currencies = splitsData.getAllCurrencies();
        assertEq(currencies.length, 2);

        vm.stopPrank();
    }

    function test_SplitsIndependence_AcrossCurrencies() public {
        vm.startPrank(admin);

        splitsData.addCurrency(address(testToken1), WEI_AMOUNT, EXCHANGE_RATE);
        splitsData.addCurrency(
            address(testToken2),
            WEI_AMOUNT * 2,
            EXCHANGE_RATE * 2
        );

        splitsData.setSplits(address(testToken1), 5000, 500 * 10 ** 18, 1);
        splitsData.setSplits(address(testToken2), 8000, 1200 * 10 ** 18, 1);

        assertEq(splitsData.getFulfillerSplit(address(testToken1), 1), 5000);
        assertEq(splitsData.getFulfillerSplit(address(testToken2), 1), 8000);
        assertEq(
            splitsData.getFulfillerBase(address(testToken1), 1),
            500 * 10 ** 18
        );
        assertEq(
            splitsData.getFulfillerBase(address(testToken2), 1),
            1200 * 10 ** 18
        );

        assertEq(splitsData.getFulfillerSplit(address(testToken1), 2), 0);
        assertEq(splitsData.getFulfillerSplit(address(testToken2), 2), 0);

        vm.stopPrank();
    }
}
