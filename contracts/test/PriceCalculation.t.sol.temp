// SPDX-License-Identifier: UNLICENSE
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../src/FGOAccessControl.sol";
import "../src/FGOMarket.sol";
import "../src/FGOParent.sol";
import "../src/FGOPatternChild.sol";
import "../src/FGOMaterialChild.sol";
import "../src/FGOPrintDesignChild.sol";
import "../src/FGOEmbellishmentsChild.sol";
import "../src/FGOConstructionChild.sol";
import "../src/FGODigitalEffectsChild.sol";
import "../src/FGOFinishingTreatmentsChild.sol";
import "../src/FGOTemplatePackChild.sol";
import "../src/FGOWorkflowExecutor.sol";
import "../src/CustomCompositeNFT.sol";
import "../src/FGOSplitsData.sol";
import "../src/FGOFulfillers.sol";
import "../src/FGODesigners.sol";
import "../src/FGOLibrary.sol";
import "../src/FGOErrors.sol";
import "../src/TestToken.sol";

contract PriceCalculationTest is Test {
    FGOAccessControl public accessControl;
    FGOMarket public market;
    FGOParent public parentFGO;
    FGOPatternChild public patternChild;
    FGOMaterialChild public materialChild;
    FGOPrintDesignChild public printDesignChild;
    FGOEmbellishmentsChild public embellishmentsChild;
    FGOConstructionChild public constructionChild;
    FGODigitalEffectsChild public digitalEffectsChild;
    FGOFinishingTreatmentsChild public finishingTreatmentsChild;
    FGOTemplatePackChild public templatePackChild;
    FGOWorkflowExecutor public workflowExecutor;
    CustomCompositeNFT public customComposite;
    FGOSplitsData public splitsData;
    FGOFulfillers public fulfillers;
    FGODesigners public designers;
    TestToken public testToken;
    
    address public admin = makeAddr("admin");
    address public supplier1 = makeAddr("supplier1");
    address public designer1 = makeAddr("designer1");
    address public fulfiller1 = makeAddr("fulfiller1");
    address public buyer1 = makeAddr("buyer1");

    uint256 public constant PARENT_PRICE = 1000 * 10**18;
    uint256 public constant PATTERN_PRICE = 100 * 10**18;
    uint256 public constant MATERIAL_PRICE = 50 * 10**18;
    uint256 public constant PRINT_PRICE = 75 * 10**18;
    uint256 public constant EMBELLISH_PRICE = 200 * 10**18;
    uint256 public constant CONSTRUCT_PRICE = 150 * 10**18;
    uint256 public constant EFFECTS_PRICE = 300 * 10**18;
    uint256 public constant FINISH_PRICE = 125 * 10**18;
    uint256 public constant TEMPLATE_PRICE = 500 * 10**18;

    uint256 public constant TOKEN_EXCHANGE_RATE = 1 * 10**18;
    uint256 public constant TOKEN_WEI_DIVISOR = 10**18;

    function setUp() public {
        vm.prank(admin);
        accessControl = new FGOAccessControl();
        
        vm.startPrank(admin);
        accessControl.addSupplier(supplier1);
        accessControl.addDesigner(designer1);
        accessControl.addFulfiller(fulfiller1);
        vm.stopPrank();

        patternChild = new FGOPatternChild(address(accessControl));
        materialChild = new FGOMaterialChild(address(accessControl));
        printDesignChild = new FGOPrintDesignChild(address(accessControl));
        embellishmentsChild = new FGOEmbellishmentsChild(address(accessControl));
        constructionChild = new FGOConstructionChild(address(accessControl));
        digitalEffectsChild = new FGODigitalEffectsChild(address(accessControl));
        finishingTreatmentsChild = new FGOFinishingTreatmentsChild(address(accessControl));
        templatePackChild = new FGOTemplatePackChild(address(accessControl));

        parentFGO = new FGOParent(address(accessControl));
        customComposite = new CustomCompositeNFT(address(accessControl));
        splitsData = new FGOSplitsData(address(accessControl));
        fulfillers = new FGOFulfillers(address(accessControl));
        designers = new FGODesigners(address(accessControl), address(parentFGO));
        workflowExecutor = new FGOWorkflowExecutor(address(accessControl), address(parentFGO), address(fulfillers));

        market = new FGOMarket(
            address(accessControl),
            address(customComposite),
            address(parentFGO),
            address(splitsData),
            address(fulfillers),
            address(patternChild),
            address(materialChild),
            address(printDesignChild),
            address(embellishmentsChild),
            address(constructionChild),
            address(digitalEffectsChild),
            address(finishingTreatmentsChild),
            address(templatePackChild),
            address(workflowExecutor)
        );

        vm.startPrank(admin);
        customComposite.authorizeMarket(address(market));
        patternChild.authorizeMarket(address(market));
        materialChild.authorizeMarket(address(market));
        printDesignChild.authorizeMarket(address(market));
        embellishmentsChild.authorizeMarket(address(market));
        constructionChild.authorizeMarket(address(market));
        digitalEffectsChild.authorizeMarket(address(market));
        finishingTreatmentsChild.authorizeMarket(address(market));
        templatePackChild.authorizeMarket(address(market));
        vm.stopPrank();

        testToken = new TestToken();
        
        vm.startPrank(admin);
        splitsData.addCurrency(address(testToken), TOKEN_WEI_DIVISOR, TOKEN_EXCHANGE_RATE);
        vm.stopPrank();

        testToken.mint(buyer1, 1000000 * 10**18);

        vm.prank(fulfiller1);
        fulfillers.createProfile("ipfs://fulfiller1");
        
        vm.prank(designer1);
        designers.createProfile("ipfs://designer1");

        vm.startPrank(supplier1);
        patternChild.createChild("ipfs://pattern1", PATTERN_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        materialChild.createChild("ipfs://material1", MATERIAL_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        printDesignChild.createChild("ipfs://print1", PRINT_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        embellishmentsChild.createChild("ipfs://embellish1", EMBELLISH_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        constructionChild.createChild("ipfs://construct1", CONSTRUCT_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        digitalEffectsChild.createChild("ipfs://effects1", EFFECTS_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        finishingTreatmentsChild.createChild("ipfs://finish1", FINISH_PRICE, 1, 0, new address[](0), 0, new address[](0), false);
        FGOLibrary.ChildPlacement[] memory emptyPlacements = new FGOLibrary.ChildPlacement[](0);
        templatePackChild.createChild("ipfs://template1", TEMPLATE_PRICE, 1, 0, new address[](0), 0, new address[](0), false, emptyPlacements);
        vm.stopPrank();
    }

    function createBasicWorkflow() internal view returns (FGOLibrary.FulfillmentWorkflow memory) {
        FGOLibrary.FulfillmentStep[] memory steps = new FGOLibrary.FulfillmentStep[](1);
        
        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller1,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: buyer1,
            instructions: "Complete workflow",
            paymentBasisPoints: 10000,
            isOptional: false,
            instructionsVersion: 1
        });
        
        return FGOLibrary.FulfillmentWorkflow({
            steps: steps,
            finalRecipient: buyer1,
            estimatedDays: 30
        });
    }

    function test_SimpleDesign_SingleChild_Amount1() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](1);
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedPrice = PARENT_PRICE + PATTERN_PRICE;
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function test_SimpleDesign_SingleChild_Amount3() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](1);
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 3
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedPrice = PARENT_PRICE + (PATTERN_PRICE * 3);
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function test_ComplexDesign_MultipleChildren_DifferentAmounts() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](4);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 2
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(materialChild),
            amount: 4
        });
        
        placements[2] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement3",
            childType: FGOLibrary.ChildType.PRINT_DESIGN,
            childContract: address(printDesignChild),
            amount: 1
        });
        
        placements[3] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement4",
            childType: FGOLibrary.ChildType.EMBELLISHMENTS,
            childContract: address(embellishmentsChild),
            amount: 3
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedPrice = PARENT_PRICE + (PATTERN_PRICE * 2) + (MATERIAL_PRICE * 4) + (PRINT_PRICE * 1) + (EMBELLISH_PRICE * 3);
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function test_AllChildTypes_MaxComplexity() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](8);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 5
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(materialChild),
            amount: 10
        });
        
        placements[2] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement3",
            childType: FGOLibrary.ChildType.PRINT_DESIGN,
            childContract: address(printDesignChild),
            amount: 3
        });
        
        placements[3] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement4",
            childType: FGOLibrary.ChildType.EMBELLISHMENTS,
            childContract: address(embellishmentsChild),
            amount: 2
        });
        
        placements[4] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement5",
            childType: FGOLibrary.ChildType.CONSTRUCTION,
            childContract: address(constructionChild),
            amount: 1
        });
        
        placements[5] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement6",
            childType: FGOLibrary.ChildType.DIGITAL_EFFECTS,
            childContract: address(digitalEffectsChild),
            amount: 4
        });
        
        placements[6] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement7",
            childType: FGOLibrary.ChildType.FINISHING_TREATMENTS,
            childContract: address(finishingTreatmentsChild),
            amount: 8
        });
        
        placements[7] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement8",
            childType: FGOLibrary.ChildType.TEMPLATE_PACK,
            childContract: address(templatePackChild),
            amount: 1
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedChildPrice = (PATTERN_PRICE * 5) + (MATERIAL_PRICE * 10) + (PRINT_PRICE * 3) + 
                                   (EMBELLISH_PRICE * 2) + (CONSTRUCT_PRICE * 1) + (EFFECTS_PRICE * 4) + 
                                   (FINISH_PRICE * 8) + (TEMPLATE_PRICE * 1);
        uint256 expectedPrice = PARENT_PRICE + expectedChildPrice;
        
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function test_DifferentCurrencyRates() public {
        TestToken expensiveToken = new TestToken();
        
        vm.prank(admin);
        splitsData.addCurrency(address(expensiveToken), TOKEN_WEI_DIVISOR, 2 * 10**18);
        
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](1);
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 2
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 normalPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(normalPrice, PARENT_PRICE + (PATTERN_PRICE * 2));
        
        uint256 expensivePrice = this.calculateUnitPriceForToken(address(expensiveToken), parentTokenId);
        assertEq(expensivePrice, (PARENT_PRICE + (PATTERN_PRICE * 2)) / 2);
    }

    function test_LargeAmounts_GasOptimization() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](3);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1000
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(materialChild),
            amount: 2000
        });
        
        placements[2] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement3",
            childType: FGOLibrary.ChildType.EMBELLISHMENTS,
            childContract: address(embellishmentsChild),
            amount: 500
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedPrice = PARENT_PRICE + (PATTERN_PRICE * 1000) + (MATERIAL_PRICE * 2000) + (EMBELLISH_PRICE * 500);
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function test_MultipleDesigns_PriceIndependence() public {
        FGOLibrary.ChildPlacement[] memory placements1 = new FGOLibrary.ChildPlacement[](1);
        placements1[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1
        });

        FGOLibrary.ChildPlacement[] memory placements2 = new FGOLibrary.ChildPlacement[](1);
        placements2[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 5
        });

        vm.startPrank(designer1);
        uint256 parentTokenId1 = parentFGO.createDesign(
            placements1, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );
        
        uint256 parentTokenId2 = parentFGO.createDesign(
            placements2, "ipfs://parent2", PARENT_PRICE * 2, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );
        vm.stopPrank();

        uint256 price1 = this.calculateUnitPriceForToken(address(testToken), parentTokenId1);
        assertEq(price1, PARENT_PRICE + PATTERN_PRICE);
        
        uint256 price2 = this.calculateUnitPriceForToken(address(testToken), parentTokenId2);
        assertEq(price2, (PARENT_PRICE * 2) + (PATTERN_PRICE * 5));
        
        assertTrue(price1 != price2);
    }

    function test_DuplicateChildTypes_DifferentAmounts() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](3);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 2
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 3
        });
        
        placements[2] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement3",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1
        });

        vm.prank(designer1);
        uint256 parentTokenId = parentFGO.createDesign(
            placements, "ipfs://parent1", PARENT_PRICE, 1,
            FGOLibrary.ParentType.DIGITAL_ONLY, createBasicWorkflow(), 0,
            new address[](0), 0
        );

        uint256 expectedPrice = PARENT_PRICE + (PATTERN_PRICE * 6);
        uint256 calculatedPrice = this.calculateUnitPriceForToken(address(testToken), parentTokenId);
        assertEq(calculatedPrice, expectedPrice);
    }

    function calculateUnitPriceForToken(address currency, uint256 parentTokenId) external view returns (uint256) {
        uint256 parentPrice = parentFGO.getParentPrice(parentTokenId);
        FGOLibrary.ChildPlacement[] memory placements = parentFGO.getParentPlacements(parentTokenId);
        uint256 childPrice = 0;

        for (uint256 i = 0; i < placements.length; i++) {
            uint256 childPriceEach;
            
            if (placements[i].childType == FGOLibrary.ChildType.PATTERN) {
                childPriceEach = patternChild.getPatternPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.MATERIAL) {
                childPriceEach = materialChild.getMaterialPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.PRINT_DESIGN) {
                childPriceEach = printDesignChild.getPrintDesignPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.EMBELLISHMENTS) {
                childPriceEach = embellishmentsChild.getEmbellishmentsPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.CONSTRUCTION) {
                childPriceEach = constructionChild.getConstructionPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.DIGITAL_EFFECTS) {
                childPriceEach = digitalEffectsChild.getDigitalEffectsPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.FINISHING_TREATMENTS) {
                childPriceEach = finishingTreatmentsChild.getFinishingTreatmentsPrice(placements[i].childId);
            } else if (placements[i].childType == FGOLibrary.ChildType.TEMPLATE_PACK) {
                childPriceEach = templatePackChild.getTemplatePackPrice(placements[i].childId);
            }
            
            childPrice += childPriceEach * placements[i].amount;
        }

        uint256 totalPrice = parentPrice + childPrice;
        
        uint256 exchangeRate = splitsData.getCurrencyRate(currency);
        uint256 weiDivisor = splitsData.getCurrencyWei(currency);
        uint256 calculatedPrice = (totalPrice * weiDivisor) / exchangeRate;

        return calculatedPrice;
    }
}