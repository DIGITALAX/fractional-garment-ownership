// SPDX-License-Identifier: UNLICENSE
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../src/FGOAccessControl.sol";
import "../src/FGOParent.sol";
import "../src/FGOPatternChild.sol";
import "../src/FGOMaterialChild.sol";
import "../src/FGOLibrary.sol";
import "../src/FGOErrors.sol";

contract FGOParentTest is Test {
    FGOAccessControl public accessControl;
    FGOParent public parentFGO;
    FGOPatternChild public patternChild;
    FGOMaterialChild public materialChild;
    
    address public admin = makeAddr("admin");
    address public designer1 = makeAddr("designer1");
    address public designer2 = makeAddr("designer2");
    address public supplier1 = makeAddr("supplier1");
    address public fulfiller1 = makeAddr("fulfiller1");
    address public unauthorizedUser = makeAddr("unauthorizedUser");

    uint256 public constant PARENT_PRICE = 500 * 10**18;
    uint256 public constant CHILD_PRICE = 100 * 10**18;

    event DesignCreated(uint256 indexed designId, address indexed designer);
    event ParentMinted(uint256 indexed tokenId, uint256 indexed designId, address indexed designer);
    event DesignMetadataUpdated(uint256 indexed designId);
    event DesignPlacementsUpdated(uint256 indexed designId);
    event MaxEditionsSet(uint256 indexed designId, uint256 maxEditions);

    function setUp() public {
        vm.prank(admin);
        accessControl = new FGOAccessControl();
        
        vm.startPrank(admin);
        accessControl.addDesigner(designer1);
        accessControl.addDesigner(designer2);
        accessControl.addSupplier(supplier1);
        accessControl.addFulfiller(fulfiller1);
        vm.stopPrank();
        
        parentFGO = new FGOParent(address(accessControl));
        patternChild = new FGOPatternChild(address(accessControl));
        materialChild = new FGOMaterialChild(address(accessControl));
        
        vm.startPrank(supplier1);
        patternChild.createChild("ipfs://pattern1", CHILD_PRICE, 1, 100);
        patternChild.createChild("ipfs://pattern2", CHILD_PRICE * 2, 1, 200);
        materialChild.createChild("ipfs://material1", CHILD_PRICE / 2, 1, 300);
        materialChild.createChild("ipfs://material2", CHILD_PRICE * 3, 1, 0);
        vm.stopPrank();
    }

    function createBasicPlacements() internal pure returns (FGOLibrary.ChildPlacement[] memory) {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](2);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(0),
            amount: 2
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(0),
            amount: 3
        });
        
        return placements;
    }

    function createBasicWorkflow() internal pure returns (FGOLibrary.FulfillmentWorkflow memory) {
        FGOLibrary.FulfillmentStep[] memory steps = new FGOLibrary.FulfillmentStep[](2);
        
        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: address(0x1),
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: address(0x2),
            instructions: "Step 1",
            paymentBasisPoints: 6000,
            isOptional: false,
            instructionsVersion: 1
        });
        
        steps[1] = FGOLibrary.FulfillmentStep({
            primaryPerformer: address(0x2),
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: address(0x3),
            instructions: "Step 2",
            paymentBasisPoints: 4000,
            isOptional: false,
            instructionsVersion: 1
        });
        
        return FGOLibrary.FulfillmentWorkflow({
            steps: steps,
            finalRecipient: address(0x3),
            estimatedDays: 30
        });
    }

    function test_CreateDesign_DesignerRole() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        vm.expectEmit(true, true, false, false);
        emit DesignCreated(1, designer1);
        vm.expectEmit(true, true, true, false);
        emit ParentMinted(1, 1, designer1);
        
        uint256 tokenId = parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.BOTH,
            workflow,
            100,
            new address[](0),
            0
        );
        
        assertEq(tokenId, 1);
        assertEq(parentFGO.ownerOf(tokenId), designer1);
        assertEq(parentFGO.getDesignSupply(), 1);
        assertEq(parentFGO.getTokenSupply(), 1);
        assertEq(parentFGO.getParentDesignId(tokenId), 1);
        assertEq(parentFGO.getCurrentEditions(1), 1);
        assertEq(parentFGO.getMaxEditions(1), 100);
    }

    function test_CreateDesign_RevertIfNotDesigner() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(supplier1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.BOTH,
            workflow,
            100,
            new address[](0),
            0
        );
        
        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.BOTH,
            workflow,
            100,
            new address[](0),
            0
        );
    }

    function test_CreateDesign_AdminCanCreate() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(admin);
        uint256 tokenId = parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.BOTH,
            workflow,
            100,
            new address[](0),
            0
        );
        
        assertEq(tokenId, 1);
        assertEq(parentFGO.ownerOf(tokenId), admin);
    }

    function test_CreateDesign_DigitalOnly() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory emptyWorkflow;
        
        vm.prank(designer1);
        uint256 tokenId = parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.DIGITAL_ONLY,
            emptyWorkflow,
            0,
            new address[](0),
            0
        );
        
        assertEq(uint256(parentFGO.getParentType(tokenId)), uint256(FGOLibrary.ParentType.DIGITAL_ONLY));
    }

    function test_CreateDesign_RevertIfPhysicalWithoutWorkflow() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory emptyWorkflow;
        
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.PHYSICAL_ONLY,
            emptyWorkflow,
            100,
            new address[](0),
            0
        );
    }

    function test_CreateDesign_RevertIfInvalidWorkflowBasisPoints() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        workflow.steps[0].paymentBasisPoints = 7000; 
        
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.BOTH,
            workflow,
            100,
            new address[](0),
            0
        );
    }

    function test_GetParentPlacements_WithAmounts() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        uint256 tokenId = parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        FGOLibrary.ChildPlacement[] memory retrievedPlacements = parentFGO.getParentPlacements(tokenId);
        
        assertEq(retrievedPlacements.length, 2);
        assertEq(retrievedPlacements[0].childId, 1);
        assertEq(retrievedPlacements[0].amount, 2);
        assertEq(uint256(retrievedPlacements[0].childType), uint256(FGOLibrary.ChildType.PATTERN));
        assertEq(retrievedPlacements[1].childId, 1);
        assertEq(retrievedPlacements[1].amount, 3);
        assertEq(uint256(retrievedPlacements[1].childType), uint256(FGOLibrary.ChildType.MATERIAL));
    }

    function test_MintCatalogItem() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        vm.prank(designer1);
        vm.expectEmit(true, true, true, false);
        emit ParentMinted(2, 1, designer1);
        uint256 tokenId = parentFGO.mintCatalogItem(1);
        
        assertEq(tokenId, 2);
        assertEq(parentFGO.ownerOf(tokenId), designer1);
        assertEq(parentFGO.getParentDesignId(tokenId), 1);
        assertEq(parentFGO.getCurrentEditions(1), 2);
        assertEq(parentFGO.getTokenSupply(), 2);
    }

    function test_MintCatalogItem_RevertIfMaxEditionsReached() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 2, new address[](0), 0);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.MaxSupplyReached.selector);
        parentFGO.mintCatalogItem(1);
    }

    function test_MintCatalogItemsBatch() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        vm.prank(designer1);
        uint256[] memory tokenIds = parentFGO.mintCatalogItemsBatch(1, 5);
        
        assertEq(tokenIds.length, 5);
        assertEq(tokenIds[0], 2);
        assertEq(tokenIds[4], 6);
        assertEq(parentFGO.getCurrentEditions(1), 6);
        assertEq(parentFGO.getTokenSupply(), 6);
        
        for (uint256 i = 0; i < 5; i++) {
            assertEq(parentFGO.ownerOf(tokenIds[i]), designer1);
            assertEq(parentFGO.getParentDesignId(tokenIds[i]), 1);
        }
    }

    function test_UpdateDesignMetadata_RevertIfAlreadyMinted() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.updateDesignMetadata(1, "ipfs://parent1-updated", PARENT_PRICE * 2);
    }


    function test_UpdateDesignPlacements_RevertIfAlreadyMinted() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        FGOLibrary.ChildPlacement[] memory newPlacements = new FGOLibrary.ChildPlacement[](1);
        newPlacements[0] = FGOLibrary.ChildPlacement({
            childId: 2,
            placementURI: "ipfs://new-placement",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(0),
            amount: 5
        });
        
        vm.prank(designer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.updateDesignPlacements(1, newPlacements);
    }

    function test_SetMaxEditions() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        vm.prank(admin);
        vm.expectEmit(true, false, false, true);
        emit MaxEditionsSet(1, 200);
        parentFGO.setMaxEditions(1, 200);
        
        assertEq(parentFGO.getMaxEditions(1), 200);
    }

    function test_SetMaxEditions_RevertIfLessThanCurrent() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        
        vm.prank(admin);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.setMaxEditions(1, 2);
    }

    function test_GetDesignerDesigns() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.startPrank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        parentFGO.createDesign(placements, "ipfs://parent2", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        vm.stopPrank();
        
        vm.prank(designer2);
        parentFGO.createDesign(placements, "ipfs://parent3", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        uint256[] memory designer1Designs = parentFGO.getDesignerDesigns(designer1);
        uint256[] memory designer2Designs = parentFGO.getDesignerDesigns(designer2);
        
        assertEq(designer1Designs.length, 2);
        assertEq(designer1Designs[0], 1);
        assertEq(designer1Designs[1], 2);
        
        assertEq(designer2Designs.length, 1);
        assertEq(designer2Designs[0], 3);
    }

    function test_DesignExists() public {
        assertEq(parentFGO.designExists(1), false);
        
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        assertEq(parentFGO.designExists(1), true);
        assertEq(parentFGO.designExists(2), false);
    }

    function test_CanMintEdition() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 3, new address[](0), 0);
        
        assertEq(parentFGO.canMintEdition(1), true);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        assertEq(parentFGO.canMintEdition(1), true);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        assertEq(parentFGO.canMintEdition(1), false);
    }

    function test_GetAvailableEditions() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 5, new address[](0), 0);
        
        assertEq(parentFGO.getAvailableEditions(1), 4);
        
        vm.prank(designer1);
        parentFGO.mintCatalogItem(1);
        assertEq(parentFGO.getAvailableEditions(1), 3);
        
        vm.prank(designer1);
        parentFGO.createDesign(placements, "ipfs://parent2", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 0, new address[](0), 0);
        assertEq(parentFGO.getAvailableEditions(2), type(uint256).max);
    }

    function test_TokenURI() public {
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        uint256 tokenId = parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        assertEq(parentFGO.tokenURI(tokenId), "ipfs://parent1");
    }

    function test_DesignerGatingDisabled() public {
        vm.prank(admin);
        accessControl.toggleDesignerGating();
        
        FGOLibrary.ChildPlacement[] memory placements = createBasicPlacements();
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(unauthorizedUser);
        uint256 tokenId = parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        assertEq(tokenId, 1);
        assertEq(parentFGO.ownerOf(tokenId), unauthorizedUser);
    }

    function test_ComplexPlacements_MultipleAmounts() public {
        FGOLibrary.ChildPlacement[] memory placements = new FGOLibrary.ChildPlacement[](4);
        
        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(0),
            amount: 1
        });
        
        placements[1] = FGOLibrary.ChildPlacement({
            childId: 2,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(0),
            amount: 3
        });
        
        placements[2] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement3",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(0),
            amount: 2
        });
        
        placements[3] = FGOLibrary.ChildPlacement({
            childId: 2,
            placementURI: "ipfs://placement4",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(0),
            amount: 5
        });
        
        FGOLibrary.FulfillmentWorkflow memory workflow = createBasicWorkflow();
        
        vm.prank(designer1);
        uint256 tokenId = parentFGO.createDesign(placements, "ipfs://parent1", PARENT_PRICE, 1, FGOLibrary.ParentType.BOTH, workflow, 100, new address[](0), 0);
        
        FGOLibrary.ChildPlacement[] memory retrievedPlacements = parentFGO.getParentPlacements(tokenId);
        
        assertEq(retrievedPlacements.length, 4);
        assertEq(retrievedPlacements[0].amount, 1);
        assertEq(retrievedPlacements[1].amount, 3);
        assertEq(retrievedPlacements[2].amount, 2);
        assertEq(retrievedPlacements[3].amount, 5);
    }

    function test_SetAccessControl() public {
        FGOAccessControl newAccessControl = new FGOAccessControl();
        
        vm.prank(admin);
        parentFGO.setAccessControl(address(newAccessControl));
        
        assertEq(address(parentFGO.accessControl()), address(newAccessControl));
    }
}