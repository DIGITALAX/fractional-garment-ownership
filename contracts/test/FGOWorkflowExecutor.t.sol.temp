// SPDX-License-Identifier: UNLICENSE
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../src/FGOAccessControl.sol";
import "../src/FGOWorkflowExecutor.sol";
import "../src/FGOParent.sol";
import "../src/FGOPatternChild.sol";
import "../src/FGOMaterialChild.sol";
import "../src/FGOFulfillers.sol";
import "../src/FGOSplitsData.sol";
import "../src/FGOLibrary.sol";
import "../src/FGOErrors.sol";
import "../src/TestToken.sol";

contract FGOWorkflowExecutorTest is Test {
    FGOAccessControl public accessControl;
    FGOWorkflowExecutor public workflowExecutor;
    FGOParent public parentFGO;
    FGOPatternChild public patternChild;
    FGOMaterialChild public materialChild;
    FGOFulfillers public fulfillers;
    FGOSplitsData public splitsData;
    TestToken public testToken;

    address public admin = makeAddr("admin");
    address public supplier1 = makeAddr("supplier1");
    address public designer1 = makeAddr("designer1");
    address public fulfiller1 = makeAddr("fulfiller1");
    address public fulfiller2 = makeAddr("fulfiller2");
    address public fulfiller3 = makeAddr("fulfiller3");
    address public buyer1 = makeAddr("buyer1");
    address public buyer2 = makeAddr("buyer2");

    uint256 public constant PARENT_PRICE = 1000 * 10 ** 18;
    uint256 public constant CHILD_PRICE = 100 * 10 ** 18;
    uint256 public constant TOTAL_PAYMENT = 2000 * 10 ** 18;

    event WorkflowInitiated(
        uint256 indexed executionId,
        uint256 indexed orderId,
        uint256 indexed parentTokenId
    );
    event StepStarted(
        uint256 indexed executionId,
        uint256 stepIndex,
        address performer
    );
    event StepCompleted(
        uint256 indexed executionId,
        uint256 stepIndex,
        address performer
    );
    event StepRejected(
        uint256 indexed executionId,
        uint256 stepIndex,
        address performer,
        string reason
    );
    event StepFailed(
        uint256 indexed executionId,
        uint256 stepIndex,
        address performer,
        string reason
    );
    event PaymentReleased(
        uint256 indexed executionId,
        uint256 stepIndex,
        address recipient,
        uint256 amount
    );
    event WorkflowCompleted(uint256 indexed executionId);
    event WorkflowFailed(uint256 indexed executionId);
    event RefundIssued(
        uint256 indexed executionId,
        address recipient,
        uint256 amount
    );
    event RefundRequested(
        uint256 indexed requestId,
        uint256 indexed executionId,
        address buyer,
        string reason
    );
    event RefundApproved(uint256 indexed requestId, address fulfiller);
    event RefundExecuted(uint256 indexed requestId, uint256 refundAmount);

    function setUp() public {
        vm.prank(admin);
        accessControl = new FGOAccessControl();

        vm.startPrank(admin);
        accessControl.addSupplier(supplier1);
        accessControl.addDesigner(designer1);
        accessControl.addFulfiller(fulfiller1);
        accessControl.addFulfiller(fulfiller2);
        accessControl.addFulfiller(fulfiller3);
        vm.stopPrank();

        patternChild = new FGOPatternChild(address(accessControl));
        materialChild = new FGOMaterialChild(address(accessControl));
        parentFGO = new FGOParent(address(accessControl));
        fulfillers = new FGOFulfillers(address(accessControl));
        splitsData = new FGOSplitsData(address(accessControl));

        workflowExecutor = new FGOWorkflowExecutor(
            address(accessControl),
            address(parentFGO),
            address(fulfillers)
        );

        vm.prank(admin);
        accessControl.authorizeMarket(admin);

        vm.prank(admin);
        accessControl.addAdmin(address(workflowExecutor));

        testToken = new TestToken();
        vm.prank(admin);
        splitsData.addCurrency(address(testToken), 10 ** 18, 1 * 10 ** 18);

        testToken.mint(admin, 10000000 * 10 ** 18);
        testToken.mint(buyer1, 10000000 * 10 ** 18);
        testToken.mint(buyer2, 10000000 * 10 ** 18);

        vm.prank(admin);
        testToken.approve(address(workflowExecutor), type(uint256).max);

        vm.prank(fulfiller1);
        fulfillers.createProfile("ipfs://fulfiller1");
        vm.prank(fulfiller2);
        fulfillers.createProfile("ipfs://fulfiller2");
        vm.prank(fulfiller3);
        fulfillers.createProfile("ipfs://fulfiller3");

        vm.startPrank(supplier1);
        patternChild.createPattern("ipfs://pattern1", CHILD_PRICE, 1, 0);
        materialChild.createMaterial("ipfs://material1", CHILD_PRICE, 1, 0);
        vm.stopPrank();
    }

    function createSingleStepWorkflow()
        internal
        view
        returns (FGOLibrary.FulfillmentWorkflow memory)
    {
        FGOLibrary.FulfillmentStep[]
            memory steps = new FGOLibrary.FulfillmentStep[](1);

        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller1,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: buyer1,
            instructions: "Complete single step",
            paymentBasisPoints: 10000,
            isOptional: false,
            instructionsVersion: 1
        });

        return
            FGOLibrary.FulfillmentWorkflow({
                steps: steps,
                finalRecipient: buyer1,
                estimatedDays: 30
            });
    }

    function createMultiStepWorkflow()
        internal
        view
        returns (FGOLibrary.FulfillmentWorkflow memory)
    {
        FGOLibrary.FulfillmentStep[]
            memory steps = new FGOLibrary.FulfillmentStep[](3);

        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller1,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: fulfiller2,
            instructions: "Step 1: Design",
            paymentBasisPoints: 4000,
            isOptional: false,
            instructionsVersion: 1
        });

        steps[1] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller2,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: fulfiller3,
            instructions: "Step 2: Production",
            paymentBasisPoints: 4000,
            isOptional: false,
            instructionsVersion: 1
        });

        steps[2] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller3,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: buyer1,
            instructions: "Step 3: Shipping",
            paymentBasisPoints: 2000,
            isOptional: false,
            instructionsVersion: 1
        });

        return
            FGOLibrary.FulfillmentWorkflow({
                steps: steps,
                finalRecipient: buyer1,
                estimatedDays: 45
            });
    }

    function createDesignWithWorkflow(
        FGOLibrary.FulfillmentWorkflow memory workflow
    ) internal returns (uint256) {
        FGOLibrary.ChildPlacement[]
            memory placements = new FGOLibrary.ChildPlacement[](2);

        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1
        });

        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(materialChild),
            amount: 1
        });

        vm.prank(designer1);
        return
            parentFGO.createDesign(
                placements,
                "ipfs://parent1",
                PARENT_PRICE,
                1,
                FGOLibrary.ParentType.PHYSICAL_ONLY,
                workflow,
                0,
                new address[](0),
                0
            );
    }

    function test_InitiateWorkflow_SingleStep() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);

        vm.expectEmit(true, true, true, false);
        emit WorkflowInitiated(1, 1, parentTokenId);
        vm.expectEmit(true, false, false, true);
        emit StepStarted(1, 0, fulfiller1);

        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        assertEq(executionId, 1);

        (
            uint256 orderId,
            uint256 returnedParentId,
            uint256 currentStep,
            uint256 totalPayment,
            address currency,
            bool isCompleted,
            bool isRejected,
            address buyer
        ) = workflowExecutor.getWorkflowExecution(executionId);

        assertEq(orderId, 1);
        assertEq(returnedParentId, parentTokenId);
        assertEq(currentStep, 0);
        assertEq(totalPayment, TOTAL_PAYMENT);
        assertEq(currency, address(testToken));
        assertEq(isCompleted, false);
        assertEq(isRejected, false);
        assertEq(buyer, buyer1);

        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.IN_PROGRESS)
        );

        uint256 expectedUpfront = (TOTAL_PAYMENT * 50) / 100;
        assertEq(testToken.balanceOf(fulfiller1), expectedUpfront);
    }

    function test_InitiateWorkflow_MultiStep() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createMultiStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);

        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        uint256 step1Payment = (TOTAL_PAYMENT * 4000) / 10000;
        uint256 step2Payment = (TOTAL_PAYMENT * 4000) / 10000;
        uint256 step3Payment = (TOTAL_PAYMENT * 2000) / 10000;

        assertEq(workflowExecutor.getStepPayment(executionId, 0), step1Payment);
        assertEq(workflowExecutor.getStepPayment(executionId, 1), step2Payment);
        assertEq(workflowExecutor.getStepPayment(executionId, 2), step3Payment);

        uint256 expectedUpfront1 = (step1Payment * 50) / 100;
        uint256 expectedUpfront2 = (step2Payment * 50) / 100;
        uint256 expectedUpfront3 = (step3Payment * 50) / 100;

        assertEq(testToken.balanceOf(fulfiller1), expectedUpfront1);
        assertEq(testToken.balanceOf(fulfiller2), expectedUpfront2);
        assertEq(testToken.balanceOf(fulfiller3), expectedUpfront3);

        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.IN_PROGRESS)
        );
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 1)),
            uint(FGOLibrary.StepStatus.PENDING)
        );
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 2)),
            uint(FGOLibrary.StepStatus.PENDING)
        );
    }

    function test_CompleteStep_SingleStep() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit StepCompleted(executionId, 0, fulfiller1);
        vm.expectEmit(true, false, false, false);
        emit WorkflowCompleted(executionId);
        workflowExecutor.completeStep(executionId);

        (, , , , , bool isCompleted, , ) = workflowExecutor
            .getWorkflowExecution(executionId);
        assertEq(isCompleted, true);
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.COMPLETED)
        );

        uint256 expectedTotal = TOTAL_PAYMENT;
        assertEq(testToken.balanceOf(fulfiller1), expectedTotal);

        assertEq(workflowExecutor.isStepPaymentReleased(executionId, 0), true);
    }

    function test_CompleteStep_MultiStepProgression() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createMultiStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit StepCompleted(executionId, 0, fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit StepStarted(executionId, 1, fulfiller2);
        workflowExecutor.completeStep(executionId);

        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.COMPLETED)
        );
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 1)),
            uint(FGOLibrary.StepStatus.IN_PROGRESS)
        );
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 2)),
            uint(FGOLibrary.StepStatus.PENDING)
        );

        (, , uint256 currentStep, , , bool isCompleted, , ) = workflowExecutor
            .getWorkflowExecution(executionId);
        assertEq(currentStep, 1);
        assertEq(isCompleted, false);

        vm.prank(fulfiller2);
        workflowExecutor.completeStep(executionId);

        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 1)),
            uint(FGOLibrary.StepStatus.COMPLETED)
        );
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 2)),
            uint(FGOLibrary.StepStatus.IN_PROGRESS)
        );

        vm.prank(fulfiller3);
        vm.expectEmit(true, false, false, false);
        emit WorkflowCompleted(executionId);
        workflowExecutor.completeStep(executionId);

        (, , , , , isCompleted, , ) = workflowExecutor.getWorkflowExecution(
            executionId
        );
        assertEq(isCompleted, true);
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 2)),
            uint(FGOLibrary.StepStatus.COMPLETED)
        );
    }

    function test_PaymentDistribution_3PartSplit() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller1);
        workflowExecutor.completeStep(executionId);

        uint256 finalBalance = testToken.balanceOf(fulfiller1);

        uint256 expectedUpfront = (TOTAL_PAYMENT * 50) / 100;
        uint256 expectedCompletion = (TOTAL_PAYMENT * 25) / 100;
        uint256 expectedFinal = (TOTAL_PAYMENT * 25) / 100;
        uint256 expectedTotal = expectedUpfront +
            expectedCompletion +
            expectedFinal;

        assertEq(finalBalance, expectedTotal);
        assertEq(finalBalance, TOTAL_PAYMENT);
    }

    function test_RejectStep() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        string memory rejectReason = "Quality issues";

        vm.prank(fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit StepRejected(executionId, 0, fulfiller1, rejectReason);
        vm.expectEmit(true, false, false, false);
        emit WorkflowFailed(executionId);
        workflowExecutor.rejectStep(executionId, rejectReason);

        (, , , , , bool isCompleted, bool isRejected, ) = workflowExecutor
            .getWorkflowExecution(executionId);
        assertEq(isCompleted, false);
        assertEq(isRejected, true);
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.REJECTED)
        );
    }

    function test_FailStep_WithRefund() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        uint256 buyerInitialBalance = testToken.balanceOf(buyer1);
        string memory failReason = "Equipment failure";

        vm.prank(admin);
        testToken.transfer(
            address(workflowExecutor),
            (TOTAL_PAYMENT * 50) / 100
        );

        vm.prank(fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit StepFailed(executionId, 0, fulfiller1, failReason);
        vm.expectEmit(true, false, false, false);
        emit WorkflowFailed(executionId);
        vm.expectEmit(true, false, false, true);
        emit RefundIssued(executionId, buyer1, TOTAL_PAYMENT);
        workflowExecutor.failStep(executionId, failReason);

        (, , , , , bool isCompleted, bool isRejected, ) = workflowExecutor
            .getWorkflowExecution(executionId);
        assertEq(isCompleted, false);
        assertEq(isRejected, true);
        assertEq(
            uint(workflowExecutor.getStepStatus(executionId, 0)),
            uint(FGOLibrary.StepStatus.FAILED)
        );

        uint256 buyerFinalBalance = testToken.balanceOf(buyer1);
        assertEq(buyerFinalBalance, buyerInitialBalance + TOTAL_PAYMENT);
    }

    function test_AdminRefund() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );

        uint256 upfrontPaid = (TOTAL_PAYMENT * 50) / 100;
        testToken.transfer(address(workflowExecutor), upfrontPaid);

        uint256 buyerInitialBalance = testToken.balanceOf(buyer1);

        vm.expectEmit(true, false, false, true);
        emit RefundIssued(executionId, buyer1, TOTAL_PAYMENT);
        workflowExecutor.adminRefund(executionId);
        vm.stopPrank();

        (, , , , , , bool isRejected, ) = workflowExecutor.getWorkflowExecution(
            executionId
        );
        assertEq(isRejected, true);

        uint256 buyerFinalBalance = testToken.balanceOf(buyer1);
        assertEq(buyerFinalBalance, buyerInitialBalance + TOTAL_PAYMENT);
    }

    function test_RequestRefund_BuyerInitiated() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        string memory refundReason = "Unsatisfied with progress";

        vm.prank(buyer1);
        vm.expectEmit(true, true, false, true);
        emit RefundRequested(1, executionId, buyer1, refundReason);
        workflowExecutor.requestRefund(executionId, refundReason);

        (
            uint256 returnedExecutionId,
            address returnedBuyer,
            string memory returnedReason,
            uint256 approvals,
            uint256 totalFulfillers,
            bool executed
        ) = workflowExecutor.getRefundRequest(1);

        assertEq(returnedExecutionId, executionId);
        assertEq(returnedBuyer, buyer1);
        assertEq(returnedReason, refundReason);
        assertEq(approvals, 0);
        assertEq(totalFulfillers, 1);
        assertEq(executed, false);
    }

    function test_FulfillerApproveRefund_SingleFulfiller() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(buyer1);
        workflowExecutor.requestRefund(executionId, "Quality issues");

        uint256 buyerInitialBalance = testToken.balanceOf(buyer1);

        vm.prank(admin);
        testToken.transfer(
            address(workflowExecutor),
            (TOTAL_PAYMENT * 50) / 100
        );

        vm.prank(fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit RefundApproved(1, fulfiller1);
        vm.expectEmit(true, false, false, true);
        emit RefundExecuted(1, TOTAL_PAYMENT);
        workflowExecutor.approveFulfillerRefund(1);

        (, , , , , bool executed) = workflowExecutor.getRefundRequest(1);
        assertEq(executed, true);

        uint256 buyerFinalBalance = testToken.balanceOf(buyer1);
        assertEq(buyerFinalBalance, buyerInitialBalance + TOTAL_PAYMENT);

        (, , , , , , bool isRejected, ) = workflowExecutor.getWorkflowExecution(
            executionId
        );
        assertEq(isRejected, true);
    }

    function test_MultiSigRefund_ThresholdNotMet() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createMultiStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(buyer1);
        workflowExecutor.requestRefund(executionId, "Delays");

        vm.prank(admin);
        testToken.transfer(
            address(workflowExecutor),
            (TOTAL_PAYMENT * 50) / 100
        );

        vm.prank(fulfiller1);
        workflowExecutor.approveFulfillerRefund(1);

        (, , , , , bool executed) = workflowExecutor.getRefundRequest(1);
        assertEq(executed, false);

        vm.prank(fulfiller2);
        vm.expectEmit(true, false, false, true);
        emit RefundExecuted(1, TOTAL_PAYMENT);
        workflowExecutor.approveFulfillerRefund(1);

        (, , , , , executed) = workflowExecutor.getRefundRequest(1);
        assertEq(executed, true);
    }

    function test_DebtCreation_AfterRefund() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createMultiStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller1);
        workflowExecutor.completeStep(executionId);

        vm.prank(buyer1);
        workflowExecutor.requestRefund(executionId, "Changed mind");

        vm.prank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);

        vm.prank(fulfiller1);
        workflowExecutor.approveFulfillerRefund(1);
        vm.prank(fulfiller2);
        workflowExecutor.approveFulfillerRefund(1);

        uint256 step1Payment = (TOTAL_PAYMENT * 4000) / 10000;
        uint256 expectedDebt = (step1Payment * 75) / 100;

        (uint256 debt1, ) = fulfillers.getFulfillerDebt(1);
        (uint256 debt2, ) = fulfillers.getFulfillerDebt(2);
        (uint256 debt3, ) = fulfillers.getFulfillerDebt(3);
        assertEq(debt1, expectedDebt);
        assertEq(debt2, 0);
        assertEq(debt3, 0);
    }

    function test_RevertIfInvalidWorkflowBasisPoints() public {
        FGOLibrary.FulfillmentStep[]
            memory steps = new FGOLibrary.FulfillmentStep[](2);

        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller1,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: fulfiller2,
            instructions: "Step 1",
            paymentBasisPoints: 6000,
            isOptional: false,
            instructionsVersion: 1
        });

        steps[1] = FGOLibrary.FulfillmentStep({
            primaryPerformer: fulfiller2,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: buyer1,
            instructions: "Step 2",
            paymentBasisPoints: 5000,
            isOptional: false,
            instructionsVersion: 1
        });

        FGOLibrary.FulfillmentWorkflow memory invalidWorkflow = FGOLibrary
            .FulfillmentWorkflow({
                steps: steps,
                finalRecipient: buyer1,
                estimatedDays: 30
            });

        FGOLibrary.ChildPlacement[]
            memory placements = new FGOLibrary.ChildPlacement[](2);

        placements[0] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement1",
            childType: FGOLibrary.ChildType.PATTERN,
            childContract: address(patternChild),
            amount: 1
        });

        placements[1] = FGOLibrary.ChildPlacement({
            childId: 1,
            placementURI: "ipfs://placement2",
            childType: FGOLibrary.ChildType.MATERIAL,
            childContract: address(materialChild),
            amount: 1
        });

        vm.prank(designer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        parentFGO.createDesign(
            placements,
            "ipfs://parent1",
            PARENT_PRICE,
            1,
            FGOLibrary.ParentType.PHYSICAL_ONLY,
            invalidWorkflow,
            0,
            new address[](0),
            0
        );
    }

    function test_RevertIfInvalidFulfiller() public {
        FGOLibrary.FulfillmentStep[]
            memory steps = new FGOLibrary.FulfillmentStep[](1);

        address nonExistentFulfiller = makeAddr("nonExistent");

        steps[0] = FGOLibrary.FulfillmentStep({
            primaryPerformer: nonExistentFulfiller,
            subPerformers: new FGOLibrary.SubPerformer[](0),
            requiredChildIds: new uint256[](0),
            shipToNext: buyer1,
            instructions: "Step 1",
            paymentBasisPoints: 10000,
            isOptional: false,
            instructionsVersion: 1
        });

        FGOLibrary.FulfillmentWorkflow memory invalidWorkflow = FGOLibrary
            .FulfillmentWorkflow({
                steps: steps,
                finalRecipient: buyer1,
                estimatedDays: 30
            });

        uint256 parentTokenId = createDesignWithWorkflow(invalidWorkflow);

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);

        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();
    }

    function test_RevertIfNotStepPerformer() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller2);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.completeStep(executionId);
    }

    function test_RevertIfNotBuyer() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(buyer2);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.requestRefund(executionId, "Wrong buyer");
    }

    function test_RevertIfCompletedWorkflow() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(fulfiller1);
        workflowExecutor.completeStep(executionId);

        vm.prank(buyer1);
        vm.expectRevert(FGOErrors.InvalidAmount.selector);
        workflowExecutor.requestRefund(executionId, "Too late");
    }

    function test_RevertIfAlreadyApproved() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createMultiStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );
        vm.stopPrank();

        vm.prank(buyer1);
        workflowExecutor.requestRefund(executionId, "Duplicate approval test");

        vm.prank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);

        vm.prank(fulfiller1);
        workflowExecutor.approveFulfillerRefund(1);

        vm.prank(fulfiller1);
        vm.expectRevert(FGOErrors.Existing.selector);
        workflowExecutor.approveFulfillerRefund(1);
    }

    function test_FundWorkflow() public {
        uint256 parentTokenId = createDesignWithWorkflow(
            createSingleStepWorkflow()
        );

        vm.startPrank(admin);
        testToken.transfer(address(workflowExecutor), TOTAL_PAYMENT);
        uint256 executionId = workflowExecutor.initiateWorkflow(
            1,
            parentTokenId,
            TOTAL_PAYMENT,
            address(testToken),
            buyer1
        );

        uint256 additionalFunding = 500 * 10 ** 18;
        testToken.approve(address(workflowExecutor), additionalFunding);
        workflowExecutor.fundWorkflow(executionId, additionalFunding);
        vm.stopPrank();

        uint256 expectedBalance = (TOTAL_PAYMENT * 50) /
            100 +
            additionalFunding;
        assertEq(
            testToken.balanceOf(address(workflowExecutor)),
            expectedBalance
        );
    }

    function test_SettersOnlyAdmin() public {
        vm.startPrank(admin);
        FGOAccessControl newAccessControl = new FGOAccessControl();
        FGOParent newParentFGO = new FGOParent(address(newAccessControl));
        FGOFulfillers newFulfillers = new FGOFulfillers(
            address(newAccessControl)
        );
        vm.stopPrank();

        vm.startPrank(admin);
        workflowExecutor.setAccessControl(address(newAccessControl));
        workflowExecutor.setParentFGO(address(newParentFGO));
        workflowExecutor.setFulfillers(address(newFulfillers));
        vm.stopPrank();

        vm.prank(buyer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.setAccessControl(address(newAccessControl));

        vm.prank(buyer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.setParentFGO(address(newParentFGO));

        vm.prank(buyer1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        workflowExecutor.setFulfillers(address(newFulfillers));
    }
}
