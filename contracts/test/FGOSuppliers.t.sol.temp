// SPDX-License-Identifier: UNLICENSE
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../src/FGOAccessControl.sol";
import "../src/FGOSuppliers.sol";
import "../src/FGOLibrary.sol";
import "../src/FGOErrors.sol";

contract FGOSuppliersTest is Test {
    FGOAccessControl public accessControl;
    FGOSuppliers public suppliers;

    address public admin = makeAddr("admin");
    address public supplier1 = makeAddr("supplier1");
    address public supplier2 = makeAddr("supplier2");
    address public supplier3 = makeAddr("supplier3");
    address public newWallet = makeAddr("newWallet");
    address public unauthorizedUser = makeAddr("unauthorizedUser");

    event SupplierRegistered(
        address indexed supplier,
        uint256 indexed supplierId,
        string uri
    );
    event SupplierURIUpdated(
        address indexed supplier,
        uint256 version,
        string newURI
    );
    event SupplierWalletTransferred(
        address indexed oldAddress,
        address indexed newAddress,
        uint256 supplierId,
        bool transferChildren
    );
    event SupplierDeactivated(address indexed supplier);
    event SupplierReactivated(address indexed supplier);

    function setUp() public {
        vm.prank(admin);
        accessControl = new FGOAccessControl();

        vm.prank(admin);
        suppliers = new FGOSuppliers(address(accessControl));
    }

    function test_Constructor() public view {
        assertEq(address(suppliers.accessControl()), address(accessControl));
    }

    function test_RegisterSupplier() public {
        string memory uri = "ipfs://supplier1-profile";
        uint256 version = 1;

        vm.prank(supplier1);
        vm.expectEmit(true, true, false, true);
        emit SupplierRegistered(supplier1, 1, uri);
        suppliers.registerSupplier(uri, version);

        assertEq(suppliers.getSupplierSupply(), 1);
        assertEq(suppliers.getSupplierAddress(1), supplier1);
        assertEq(suppliers.getSupplierId(supplier1), 1);
        assertEq(suppliers.isValidSupplier(supplier1), true);

        FGOLibrary.FulfillerProfile memory profile = suppliers
            .getSupplierProfile(supplier1);
        assertEq(profile.fulfillerAddress, supplier1);
        assertEq(profile.uri, uri);
        assertEq(profile.isActive, true);
        assertEq(profile.version, version);
        assertEq(profile.totalDebt, 0);
        assertEq(profile.isBlacklisted, false);
    }

    function test_RegisterSupplier_RevertIfAlreadyRegistered() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(supplier1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.registerSupplier("ipfs://supplier1-new", 2);
    }

    function test_RegisterMultipleSuppliers() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(supplier2);
        suppliers.registerSupplier("ipfs://supplier2", 1);

        vm.prank(supplier3);
        suppliers.registerSupplier("ipfs://supplier3", 1);

        assertEq(suppliers.getSupplierSupply(), 3);
        assertEq(suppliers.getSupplierAddress(1), supplier1);
        assertEq(suppliers.getSupplierAddress(2), supplier2);
        assertEq(suppliers.getSupplierAddress(3), supplier3);
        assertEq(suppliers.getSupplierId(supplier1), 1);
        assertEq(suppliers.getSupplierId(supplier2), 2);
        assertEq(suppliers.getSupplierId(supplier3), 3);
    }

    function test_UpdateSupplierURI() public {
        vm.prank(admin);
        accessControl.addSupplier(supplier1);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        string memory newUri = "ipfs://supplier1-updated";
        uint256 newVersion = 2;

        vm.prank(supplier1);
        vm.expectEmit(true, false, false, true);
        emit SupplierURIUpdated(supplier1, newVersion, newUri);
        suppliers.updateSupplierURI(newUri, newVersion);

        assertEq(suppliers.getSupplierURI(supplier1), newUri);
        assertEq(suppliers.getSupplierVersion(supplier1), newVersion);
    }

    function test_UpdateSupplierURI_RevertIfNotSupplier() public {
        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.updateSupplierURI("ipfs://fake", 1);
    }

    function test_UpdateSupplierURI_RevertIfNotRegistered() public {
        vm.prank(supplier1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.updateSupplierURI("ipfs://supplier1", 1);
    }

    function test_UpdateSupplierURI_AdminCannotUpdate() public {
        vm.prank(admin);
        accessControl.addSupplier(supplier1);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(admin);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.updateSupplierURI("ipfs://admin-updated", 3);
    }

    function test_TransferSupplierWallet() public {
        vm.prank(admin);
        accessControl.addSupplier(supplier1);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(supplier1);
        vm.expectEmit(true, true, true, true);
        emit SupplierWalletTransferred(supplier1, newWallet, 1, false);
        suppliers.transferSupplierWallet(newWallet, false);

        assertEq(suppliers.getSupplierAddress(1), newWallet);
        assertEq(suppliers.getSupplierId(supplier1), 0);
        assertEq(suppliers.getSupplierId(newWallet), 1);
        assertEq(suppliers.isValidSupplier(supplier1), false);
        assertEq(suppliers.isValidSupplier(newWallet), true);

        FGOLibrary.FulfillerProfile memory profile = suppliers
            .getSupplierProfile(newWallet);
        assertEq(profile.fulfillerAddress, newWallet);
        assertEq(profile.uri, "ipfs://supplier1");
    }

    function test_TransferSupplierWallet_WithChildren() public {
        vm.prank(admin);
        accessControl.addSupplier(supplier1);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.startPrank(admin);
        suppliers.addChildToSupplier(supplier1, 1);
        suppliers.addChildToSupplier(supplier1, 2);
        vm.stopPrank();

        assertEq(suppliers.getSupplierChildrenCount(supplier1), 2);

        vm.prank(supplier1);
        suppliers.transferSupplierWallet(newWallet, true);

        assertEq(suppliers.getSupplierChildrenCount(supplier1), 0);
        assertEq(suppliers.getSupplierChildrenCount(newWallet), 2);

        uint256[] memory children = suppliers.getSupplierChildren(newWallet);
        assertEq(children[0], 1);
        assertEq(children[1], 2);
    }

    function test_TransferSupplierWallet_RevertIfNewWalletExists() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(supplier2);
        suppliers.registerSupplier("ipfs://supplier2", 1);

        vm.prank(supplier1);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.transferSupplierWallet(supplier2, false);
    }

    function test_TransferSupplierWallet_RevertIfNotOwner() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.transferSupplierWallet(newWallet, false);
    }

    function test_DeactivateSupplier() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        assertEq(suppliers.isSupplierActive(supplier1), true);
        assertEq(suppliers.isValidSupplier(supplier1), true);

        vm.prank(admin);
        vm.expectEmit(true, false, false, false);
        emit SupplierDeactivated(supplier1);
        suppliers.deactivateSupplier(supplier1);

        assertEq(suppliers.isSupplierActive(supplier1), false);
        assertEq(suppliers.isValidSupplier(supplier1), false);
    }

    function test_ReactivateSupplier() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(admin);
        suppliers.deactivateSupplier(supplier1);

        vm.prank(admin);
        vm.expectEmit(true, false, false, false);
        emit SupplierReactivated(supplier1);
        suppliers.reactivateSupplier(supplier1);

        assertEq(suppliers.isSupplierActive(supplier1), true);
        assertEq(suppliers.isValidSupplier(supplier1), true);
    }

    function test_DeactivateSupplier_RevertIfNotAdmin() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.deactivateSupplier(supplier1);
    }

    function test_AddChildToSupplier() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.startPrank(admin);
        suppliers.addChildToSupplier(supplier1, 1);
        suppliers.addChildToSupplier(supplier1, 2);
        suppliers.addChildToSupplier(supplier1, 3);
        vm.stopPrank();

        assertEq(suppliers.getSupplierChildrenCount(supplier1), 3);

        uint256[] memory children = suppliers.getSupplierChildren(supplier1);
        assertEq(children.length, 3);
        assertEq(children[0], 1);
        assertEq(children[1], 2);
        assertEq(children[2], 3);
    }

    function test_AddChildToSupplier_RevertIfNotAuthorized() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.addChildToSupplier(supplier1, 1);
    }

    function test_SetAccessControl() public {
        FGOAccessControl newAccessControl = new FGOAccessControl();

        vm.prank(admin);
        suppliers.setAccessControl(address(newAccessControl));

        assertEq(address(suppliers.accessControl()), address(newAccessControl));
    }

    function test_SetAccessControl_RevertIfNotAdmin() public {
        FGOAccessControl newAccessControl = new FGOAccessControl();

        vm.prank(unauthorizedUser);
        vm.expectRevert(FGOErrors.AddressInvalid.selector);
        suppliers.setAccessControl(address(newAccessControl));
    }

    function test_SupplierExists() public {
        assertEq(suppliers.supplierExists(1), false);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        assertEq(suppliers.supplierExists(1), true);
        assertEq(suppliers.supplierExists(2), false);
    }

    function test_GetSupplierProfile_NonExistent() public view {
        FGOLibrary.FulfillerProfile memory profile = suppliers
            .getSupplierProfile(supplier1);
        assertEq(profile.fulfillerAddress, address(0));
        assertEq(profile.uri, "");
        assertEq(profile.isActive, false);
        assertEq(profile.version, 0);
    }

    function test_GetSupplierURI_NonExistent() public view {
        assertEq(suppliers.getSupplierURI(supplier1), "");
    }

    function test_GetSupplierVersion_NonExistent() public view {
        assertEq(suppliers.getSupplierVersion(supplier1), 0);
    }

    function test_IsSupplierActive_NonExistent() public view {
        assertEq(suppliers.isSupplierActive(supplier1), false);
    }

    function test_GetSupplierChildren_Empty() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        uint256[] memory children = suppliers.getSupplierChildren(supplier1);
        assertEq(children.length, 0);
        assertEq(suppliers.getSupplierChildrenCount(supplier1), 0);
    }

    function test_SupplierChildrenManagement() public {
        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(supplier2);
        suppliers.registerSupplier("ipfs://supplier2", 1);

        vm.startPrank(admin);
        suppliers.addChildToSupplier(supplier1, 1);
        suppliers.addChildToSupplier(supplier1, 3);
        suppliers.addChildToSupplier(supplier1, 5);

        suppliers.addChildToSupplier(supplier2, 2);
        suppliers.addChildToSupplier(supplier2, 4);
        vm.stopPrank();

        assertEq(suppliers.getSupplierChildrenCount(supplier1), 3);
        assertEq(suppliers.getSupplierChildrenCount(supplier2), 2);

        uint256[] memory children1 = suppliers.getSupplierChildren(supplier1);
        uint256[] memory children2 = suppliers.getSupplierChildren(supplier2);

        assertEq(children1[0], 1);
        assertEq(children1[1], 3);
        assertEq(children1[2], 5);

        assertEq(children2[0], 2);
        assertEq(children2[1], 4);
    }

    function test_CompleteSupplierWorkflow() public {
        vm.prank(admin);
        accessControl.addSupplier(supplier1);

        vm.prank(supplier1);
        suppliers.registerSupplier("ipfs://supplier1", 1);

        vm.prank(admin);
        suppliers.addChildToSupplier(supplier1, 1);

        vm.prank(supplier1);
        suppliers.updateSupplierURI("ipfs://supplier1-v2", 2);

        assertEq(suppliers.getSupplierURI(supplier1), "ipfs://supplier1-v2");
        assertEq(suppliers.getSupplierVersion(supplier1), 2);
        assertEq(suppliers.getSupplierChildrenCount(supplier1), 1);

        vm.prank(supplier1);
        suppliers.transferSupplierWallet(newWallet, true);

        assertEq(suppliers.getSupplierAddress(1), newWallet);
        assertEq(suppliers.getSupplierChildrenCount(newWallet), 1);
        assertEq(suppliers.isValidSupplier(newWallet), true);
        assertEq(suppliers.isValidSupplier(supplier1), false);
    }
}
