type FGOUser @entity {
  id: Bytes!
  ownedInfrastructures: [Infrastructure!]
  adminInfrastructures: [Infrastructure!]
  supplierRoles: [Supplier!]
  designerRoles: [Designer!]
  fulfillerRoles: [Fulfiller!]
  futureCredits: [FutureCredit!]
}

type GlobalRegistry @entity {
  id: String!
  allDesigners: [Designer!]!
  allSuppliers: [Supplier!]!
  allInfrastructures: [Infrastructure!]
}

type Infrastructure @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  accessControlContract: Bytes!
  supplierContract: Bytes!
  designerContract: Bytes!
  fulfillerContract: Bytes!
  isDesignerGated: Boolean
  isSupplierGated: Boolean
  isPaymentTokenLocked: Boolean
  adminControlRevoked: Boolean
  suppliers: [Supplier!]
  designers: [Designer!]
  fulfillers: [Fulfiller!]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  paymentToken: Bytes!
  templates: [TemplateContract!]
  parents: [ParentContract!]
  children: [ChildContract!]
  uri: String!
  metadata: FactoryMetadata
  isActive: Boolean
  superAdmin: Bytes!
  markets: [MarketContract!]
}

type ChildContract @entity {
  id: Bytes!
  infraId: Bytes!
  childType: BigInt!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  supplierContract: Bytes!
  title: String!
  symbol: String!
  scm: String!
  children: [Child!]
  isActive: Boolean
}

type ParentContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  designerContract: Bytes!
  title: String!
  symbol: String!
  scm: String!
  parentURI: String!
  parentMetadata: ParentURIMetadata
  parents: [Parent!]
  isActive: Boolean
}

type MarketContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  fulfillerContract: Bytes!
  fulfillmentContract: Bytes!
  title: String!
  symbol: String!
  marketURI: String!
  marketMetadata: MarketURIMetadata
  orders: [Order!]
  isActive: Boolean
}

type TemplateContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  supplierContract: Bytes!
  childType: BigInt!
  title: String!
  symbol: String!
  scm: String!
  templates: [Template!]
  isActive: Boolean
}

type Child @entity {
  id: Bytes!
  childId: BigInt!
  childContract: Bytes!
  mintedTransactionHash: Bytes
  supplier: Bytes!
  supplierProfile: Supplier
  childType: BigInt!
  scm: String!
  title: String!
  symbol: String!
  infraId: Bytes!
  totalPrepaidUsed: BigInt
  totalPrepaidAmount: BigInt
  totalReservedSupply: BigInt
  digitalPrice: BigInt!
  physicalPrice: BigInt!
  infraCurrency: Bytes!
  version: BigInt!
  futures: FuturePosition
  maxPhysicalEditions: BigInt!
  currentPhysicalEditions: BigInt!
  currentDigitalEditions: BigInt
  uriVersion: BigInt!
  usageCount: BigInt!
  supplyCount: BigInt!
  uri: String!
  status: Int!
  availability: Int!
  isImmutable: Boolean!
  digitalMarketsOpenToAll: Boolean!
  physicalMarketsOpenToAll: Boolean!
  digitalReferencesOpenToAll: Boolean!
  physicalReferencesOpenToAll: Boolean!
  standaloneAllowed: Boolean!
  authorizedMarkets: [MarketContract!]
  authorizedParents: [Parent!]
  authorizedTemplates: [Template!]
  parentRequests: [ParentRequests!]
  templateRequests: [TemplateRequests!]
  marketRequests: [MarketRequest!]
  createdAt: BigInt!
  updatedAt: BigInt!
  metadata: ChildMetadata
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  physicalRights: [PhysicalRights!]
}

type PhysicalRights @entity {
  id: Bytes!
  buyer: Bytes!
  childId: BigInt!
  orderId: BigInt!
  child: Child!
  guaranteedAmount: BigInt!
  purchaseMarket: Bytes!
  order: Order
}

type ParentRequests @entity {
  id: Bytes!
  childId: BigInt!
  parentId: BigInt!
  parentContract: Bytes!
  isPending: Boolean
  parent: Parent
  approved: Boolean
  isPhysical: Boolean
  requestedAmount: BigInt
  approvedAmount: BigInt
  timestamp: BigInt
}

type TemplateRequests @entity {
  id: Bytes!
  childId: BigInt!
  requestedAmount: BigInt
  templateId: BigInt!
  templateContract: Bytes!
  isPending: Boolean
  approved: Boolean
  isPhysical: Boolean
  template: Template
  approvedAmount: BigInt
  timestamp: BigInt
}

type MarketRequest @entity {
  id: Bytes!
  tokenId: BigInt!
  marketContract: Bytes!
  isPending: Boolean
  approved: Boolean
  timestamp: BigInt
}

type Parent @entity {
  id: Bytes!
  infraId: Bytes
  designId: BigInt
  parentContract: Bytes
  designer: Bytes
  designerProfile: Designer
  scm: String
  title: String
  symbol: String
  digitalPrice: BigInt
  physicalPrice: BigInt
  infraCurrency: Bytes
  printType: Int
  availability: Int
  digitalMarketsOpenToAll: Boolean
  physicalMarketsOpenToAll: Boolean
  authorizedMarkets: [MarketContract!]
  status: Int
  totalPurchases: BigInt
  totalPhysicalPrice: BigInt
  totalDigitalPrice: BigInt
  maxDigitalEditions: BigInt
  maxPhysicalEditions: BigInt
  currentDigitalEditions: BigInt
  currentPhysicalEditions: BigInt
  childReferences: [ChildReference!]
  allNested: [ChildReference!]
  supplyRequests: [ChildSupplyRequest!]
  tokenIds: [BigInt!]
  createdAt: BigInt
  updatedAt: BigInt
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  uri: String
  metadata: ParentMetadata
  marketRequests: [MarketRequest!]
  authorizedChildren: [Child!]
  authorizedTemplates: [Template!]
  workflow: FulfillmentWorkflow
}

type ChildSupplyRequest @entity {
  id: Bytes!
  existingChildId: BigInt
  existingChild: Child
  quantity: BigInt
  preferredMaxPrice: BigInt
  deadline: BigInt
  existingChildContract: Bytes
  isPhysical: Boolean
  expired: Boolean
  customSpec: String
  placementURI: String
  parent: Parent
  proposals: [SupplierProposal!]
  matchedChildId: BigInt
  matchedSupplier: Bytes
  matchedChildContract: Bytes
  matchedChild: Child
  paid: Boolean
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  paidBlockNumber: BigInt
  paidBlockTimestamp: BigInt
  paidTransactionHash: Bytes
}

type SupplierProposal @entity {
  id: Bytes!
  childId: BigInt!
  timestamp: BigInt!
  childContract: Bytes!
  supplier: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  positionId: Bytes!
  child: Child
}

type ChildReference @entity {
  id: Bytes!
  parent: Parent
  template: Template
  childContract: Bytes!
  childId: BigInt!
  amount: BigInt!
  prepaidAmount: BigInt
  prepaidUsed: BigInt
  isTemplate: Boolean
  child: Child
  childTemplate: Template
  placementURI: String
}

type Template @entity {
  id: Bytes!
  templateId: BigInt
  templateContract: Bytes
  supplier: Bytes
  supplierProfile: Supplier
  childType: BigInt
  scm: String
  title: String
  symbol: String
  infraId: Bytes
  digitalPrice: BigInt
  physicalPrice: BigInt
  infraCurrency: Bytes
  version: BigInt
  maxPhysicalEditions: BigInt
  currentPhysicalEditions: BigInt
  currentDigitalEditions: BigInt
  uriVersion: BigInt
  usageCount: BigInt
  supplyCount: BigInt
  uri: String
  metadata: ChildMetadata
  status: Int
  availability: Int
  isImmutable: Boolean
  maxDigitalEditions: BigInt
  digitalMarketsOpenToAll: Boolean
  physicalMarketsOpenToAll: Boolean
  digitalReferencesOpenToAll: Boolean
  physicalReferencesOpenToAll: Boolean
  standaloneAllowed: Boolean
  authorizedMarkets: [MarketContract!]
  childReferences: [ChildReference!]
  allNested: [ChildReference!]
  createdAt: BigInt
  updatedAt: BigInt
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  authorizedParents: [Parent!]
  authorizedTemplates: [Template!]
  parentRequests: [ParentRequests!]
  templateRequests: [TemplateRequests!]
  marketRequests: [MarketRequest!]
  authorizedChildren: [Child!]
  physicalRights: [PhysicalRights!]
}

type ParentURIMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
}

type MarketURIMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
}

type Supplier @entity {
  id: Bytes!
  infraId: Bytes!
  supplier: Bytes
  supplierId: BigInt
  uri: String
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  isActive: Boolean
  version: BigInt
  metadata: SupplierMetadata
  children: [Child!]
  templates: [Template!]
  futures: [Child!]
  childContracts: [ChildContract!]
  templateContracts: [TemplateContract!]
}

type Designer @entity {
  id: Bytes!
  infraId: Bytes!
  designerId: BigInt
  designer: Bytes
  blockNumber: BigInt
  isActive: Boolean
  blockTimestamp: BigInt
  transactionHash: Bytes
  uri: String
  version: BigInt
  metadata: DesignerMetadata
  parents: [Parent!]
  parentContracts: [ParentContract!]
}

type Fulfiller @entity {
  id: Bytes!
  infraId: Bytes!
  fulfillerId: BigInt
  fulfiller: Bytes
  blockNumber: BigInt
  isActive: Boolean
  blockTimestamp: BigInt
  transactionHash: Bytes
  uri: String
  version: BigInt
  metadata: FulfillerMetadata
  accessControlContract: Bytes!
  basePrice: BigInt
  marketContracts: [MarketContract!]
  fulfillments: [Fulfillment!]
  vigBasisPoints: BigInt
  orders: [Order!]
}

type SupplierMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type DesignerMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type FactoryMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
}

type FulfillerMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type ChildMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
  attachments: [Attachment!]
  tags: [String!]
  prompt: String
  aiModel: String
  loras: [String!]
  workflow: String
  version: String
}

type Attachment @entity {
  id: String!
  uri: String
  type: String
}

type ParentMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
  tags: [String!]
  prompt: String
  attachments: [Attachment!]
  aiModel: String
  loras: [String!]
  workflow: String
  version: String
}

type Order @entity {
  id: Bytes!
  orderId: BigInt!
  market: MarketContract!
  buyer: Bytes!
  totalPayments: BigInt!
  orderStatus: BigInt!
  fulfillmentData: String
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  payments: [Payment!]
  parentId: BigInt
  parentAmount: BigInt
  childId: BigInt
  childAmount: BigInt
  templateId: BigInt
  templateAmount: BigInt
  parentContract: Bytes
  childContract: Bytes
  templateContract: Bytes
  isPhysical: Boolean!
  parent: Parent
  child: Child
  template: Template
  fulfillment: Fulfillment
}

type Payment @entity {
  id: Bytes!
  order: Order!
  fulfillerId: BigInt!
  amount: BigInt!
  recipient: Bytes!
  paymentType: BigInt!
}

type OrderReceipt @entity {
  id: Bytes!
  orderId: BigInt!
  buyer: Bytes!
  timestamp: BigInt!
  status: BigInt!
  params: PurchaseParams!
  breakdown: PaymentBreakdown!
}

type PurchaseParams @entity {
  id: Bytes!
  parentId: BigInt
  parentAmount: BigInt
  childId: BigInt
  childAmount: BigInt
  templateId: BigInt
  templateAmount: BigInt
  parentContract: Bytes
  childContract: Bytes
  templateContract: Bytes
  isPhysical: Boolean!
  fulfillmentData: String!
}

type PaymentBreakdown @entity {
  id: Bytes!
  totalPayments: BigInt!
  payments: [PaymentItem!]
}

type PaymentItem @entity {
  id: Bytes!
  fulfillerId: BigInt!
  amount: BigInt!
  recipient: Bytes!
  paymentType: BigInt!
}

type FulfillmentWorkflow @entity {
  id: Bytes!
  parent: Parent!
  estimatedDeliveryDuration: BigInt
  digitalSteps: [FulfillmentStep!]
  physicalSteps: [FulfillmentStep!]
}

type FulfillmentStep @entity {
  id: Bytes!
  workflow: FulfillmentWorkflow
  fulfiller: Fulfiller
  instructions: String
  subPerformers: [SubPerformer!]
}

type SubPerformer @entity {
  id: Bytes!
  step: FulfillmentStep!
  performer: Bytes!
  splitBasisPoints: BigInt!
}

type Fulfillment @entity {
  id: Bytes!
  orderId: BigInt!
  parent: Parent!
  currentStep: BigInt!
  createdAt: BigInt!
  lastUpdated: BigInt!
  isPhysical: Boolean!
  order: Order!
  contract: Bytes!
  estimatedDeliveryDuration: BigInt
  fulfillmentOrderSteps: [FulfillmentOrderStep!]
  digitalSteps: [FulfillmentStep!]
  physicalSteps: [FulfillmentStep!]
}

type FulfillmentOrderStep @entity {
  id: Bytes!
  notes: String
  completedAt: BigInt
  isCompleted: Boolean
  stepIndex: BigInt
}

type FutureCredit @entity {
  id: Bytes! # childContract-childId-buyer
  childContract: Bytes!
  childId: BigInt!
  child: Child
  tokenId: BigInt!
  buyer: Bytes! # address del buyer
  credits: BigInt!
  consumed: BigInt!
  position: FuturePosition
  supplier: Supplier
  designer: Designer
}

type Settlement @entity {
  id: Bytes!
  future: FuturePosition!
  buyer: Bytes! # address
  credits: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PurchaseRecord @entity {
  id: Bytes!
  amount: BigInt!
  totalCost: BigInt!
  buyer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  future: FuturePosition!
  order: SellOrder
}

type SellOrder @entity {
  id: Bytes!
  future: FuturePosition!
  seller: Bytes!
  amount: BigInt!
  pricePerUnit: BigInt!
  orderId: BigInt!
  isActive: Boolean!
  isClosed: Boolean
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  protocolFee: BigInt
  lpFee: BigInt
  fillers: [PurchaseRecord!]
  filled: Boolean!
}

type FuturePosition @entity {
  id: Bytes!
  supplier: Bytes!
  supplierProfile: Supplier
  totalAmount: BigInt!
  soldAmount: BigInt!
  pricePerUnit: BigInt!
  tokenId: BigInt!
  settlementRewardBPS: BigInt
  deadline: BigInt!
  isSettled: Boolean
  isActive: Boolean
  isClosed: Boolean
  purchases: [PurchaseRecord!]
  sellOrders: [SellOrder!]
  blockNumber: BigInt!
  child: Child
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  settlements: [Settlement!]
  closed: Boolean
  closedBlockNumber: BigInt
  closedBlockTimestamp: BigInt
  closedTransactionHash: Bytes
  settler: Bytes
  settlementReward: BigInt
  settlementBlockNumber: BigInt
  settlementBlockTimestamp: BigInt
  settlementTransactionHash: Bytes
}
