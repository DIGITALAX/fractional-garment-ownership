type FGOUser @entity {
  id: Bytes!
  ownedInfrastructures: [Infrastructure!]
  adminInfrastructures: [Infrastructure!]
  supplierRoles: [Supplier!]
  designerRoles: [Designer!]
  fulfillerRoles: [Fulfiller!]
}

type Infrastructure @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  accessControlContract: Bytes!
  supplierContract: Bytes!
  designerContract: Bytes!
  fulfillerContract: Bytes!
  isDesignerGated: Boolean
  isSupplierGated: Boolean
  isPaymentTokenLocked: Boolean
  adminControlRevoked: Boolean
  suppliers: [Supplier!]
  designers: [Designer!]
  fulfillers: [Fulfiller!]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  paymentToken: Bytes!
  templates: [TemplateContract!]
  parents: [ParentContract!]
  children: [ChildContract!]
  uri: String!
  metadata: FactoryMetadata
  isActive: Boolean!
  superAdmin: Bytes!
  markets: [MarketContract!]
}

type ChildContract @entity {
  id: Bytes!
  infraId: Bytes!
  childType: BigInt!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  supplierContract: Bytes!
  title: String!
  symbol: String!
  scm: String!
  children: [Child!]
}

type ParentContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  designerContract: Bytes!
  title: String!
  symbol: String!
  scm: String!
  parentURI: String!
  parentMetadata: ParentURIMetadata
  parents: [Parent!]
}

type MarketContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  title: String!
  symbol: String!
  marketURI: String!
  marketMetadata: MarketURIMetadata
  orders: [Order!]
}

type TemplateContract @entity {
  id: Bytes!
  infraId: Bytes!
  deployer: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
  supplierContract: Bytes!
  childType: BigInt!
  title: String!
  symbol: String!
  scm: String!
  templates: [Template!]
}

type Child @entity {
  id: Bytes!
  childId: BigInt!
  childContract: Bytes!
  supplier: Bytes!
  supplierProfile: Supplier
  childType: BigInt!
  scm: String!
  title: String!
  symbol: String!
  digitalPrice: BigInt!
  physicalPrice: BigInt!
  infraCurrency: Bytes!
  version: BigInt!
  maxPhysicalFulfillments: BigInt!
  physicalFulfillments: BigInt!
  uriVersion: BigInt!
  usageCount: BigInt!
  supplyCount: BigInt!
  uri: String!
  status: Int!
  availability: Int!
  isImmutable: Boolean!
  digitalOpenToAll: Boolean!
  physicalOpenToAll: Boolean!
  digitalReferencesOpenToAll: Boolean!
  physicalReferencesOpenToAll: Boolean!
  standaloneAllowed: Boolean!
  authorizedMarkets: [String!]
  authorizedParents: [Parent!]
  authorizedTemplates: [Template!]
  parentRequests: [ParentRequests!]
  templateRequests: [TemplateRequests!]
  marketRequests: [MarketRequest!]
  createdAt: BigInt!
  updatedAt: BigInt!
  metadata: ChildMetadata
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  physicalRights: [PhysicalRights!]
}

type PhysicalRights @entity {
  id: Bytes!
  buyer: Bytes!
  childId: BigInt!
  child: Child!
  guaranteedAmount: BigInt!
  nonGuaranteedAmount: BigInt!
  purchaseMarket: Bytes!
}

type ParentRequests @entity {
  id: Bytes!
  childId: BigInt!
  parentId: BigInt!
  parentContract: Bytes!
  isPending: Boolean
  approved: Boolean
  requestedAmount: BigInt!
  approvedAmount: BigInt
  timestamp: BigInt!
}

type TemplateRequests @entity {
  id: Bytes!
  childId: BigInt!
  requestedAmount: BigInt!
  templateId: BigInt!
  templateContract: Bytes!
  isPending: Boolean
  approved: Boolean
  approvedAmount: BigInt!
  timestamp: BigInt!
}

type MarketRequest @entity {
  id: Bytes!
  tokenId: BigInt!
  marketContract: Bytes!
  isPending: Boolean
  approved: Boolean
  timestamp: BigInt!
}

type Parent @entity {
  id: Bytes!
  infraId: Bytes!
  designId: BigInt!
  parentContract: Bytes!
  designer: Bytes!
  designerProfile: Designer
  scm: String!
  title: String!
  symbol: String!
  digitalPrice: BigInt!
  physicalPrice: BigInt!
  infraCurrency: Bytes!
  printType: Int!
  availability: Int!
  digitalMarketsOpenToAll: Boolean!
  physicalMarketsOpenToAll: Boolean!
  authorizedMarkets: [String!]
  status: Int!
  totalPurchases: BigInt!
  maxDigitalEditions: BigInt!
  maxPhysicalEditions: BigInt!
  currentDigitalEditions: BigInt!
  currentPhysicalEditions: BigInt!
  childReferences: [ChildReference!]
  tokenIds: [BigInt!]
  createdAt: BigInt!
  updatedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  uri: String!
  metadata: ParentMetadata
  marketRequests: [MarketRequest!]
  authorizedChildren: [Child!]
  authorizedTemplates: [Template!]
  workflow: FulfillmentWorkflow
}

type ChildReference @entity {
  id: Bytes!
  parent: Parent!
  childContract: Bytes!
  childId: BigInt!
  amount: BigInt!
  isTemplate: Boolean!
  child: Child!
}

type Template @entity {
  id: Bytes!
  templateId: BigInt!
  templateContract: Bytes!
  supplier: Bytes!
  supplierProfile: Supplier
  childType: BigInt!
  scm: String!
  title: String!
  symbol: String!
  digitalPrice: BigInt!
  physicalPrice: BigInt!
  infraCurrency: Bytes!
  version: BigInt!
  maxPhysicalFulfillments: BigInt!
  physicalFulfillments: BigInt!
  uriVersion: BigInt!
  usageCount: BigInt!
  supplyCount: BigInt!
  uri: String!
  metadata: ChildMetadata
  status: Int!
  availability: Int!
  isImmutable: Boolean!
  digitalOpenToAll: Boolean!
  physicalOpenToAll: Boolean!
  digitalReferencesOpenToAll: Boolean!
  physicalReferencesOpenToAll: Boolean!
  standaloneAllowed: Boolean!
  authorizedMarkets: [String!]
  childReferences: [ChildReference!]
  createdAt: BigInt!
  updatedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  authorizedParents: [Parent!]
  authorizedTemplates: [Template!]
  parentRequests: [ParentRequests!]
  templateRequests: [TemplateRequests!]
  marketRequests: [MarketRequest!]
  authorizedChildren: [Child!]
  physicalRights: [PhysicalRights!]
}

type ParentURIMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
}

type MarketURIMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
}

type ChildReference @entity {
  id: Bytes!
  template: Template!
  childContract: Bytes!
  childId: BigInt!
  amount: BigInt!
  uri: String!
  child: Child!
}

type Supplier @entity {
  id: Bytes!
  infraId: Bytes!
  supplier: Bytes
  supplierId: BigInt
  uri: String
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  isActive: Boolean
  version: BigInt
  metadata: SupplierMetadata
  children: [Child!]
  templates: [Template!]
  childContracts: [ChildContract!]
  templateContracts: [TemplateContract!]
}

type Designer @entity {
  id: Bytes!
  infraId: Bytes!
  designerId: BigInt
  designer: Bytes
  blockNumber: BigInt
  isActive: Boolean
  blockTimestamp: BigInt
  transactionHash: Bytes
  uri: String
  version: BigInt
  metadata: DesignerMetadata
  parents: [Parent!]
  parentContracts: [ParentContract!]
}

type Fulfiller @entity {
  id: Bytes!
  infraId: Bytes!
  fulfillerId: BigInt
  fulfiller: Bytes
  blockNumber: BigInt
  isActive: Boolean
  blockTimestamp: BigInt
  transactionHash: Bytes
  uri: String
  version: BigInt
  metadata: FulfillerMetadata
  accessControlContract: Bytes!
  basePrice: BigInt
  marketContracts: [MarketContract!]
  vigBasisPoints: BigInt
  orders: [Order!]
}

type SupplierMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type DesignerMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type FactoryMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
}

type FulfillerMetadata @entity {
  id: String!
  image: String
  title: String
  description: String
  link: String
}

type ChildMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
  attachments: [Attachment!]
  tags: [String!]
  prompt: String
  aiModel: String
  loras: [String!]
  workflow: String
  version: String
}

type Attachment @entity {
  id: String!
  uri: String
  type: String
}

type ParentMetadata @entity {
  id: String!
  title: String
  description: String
  image: String
  tags: [String!]
  prompt: String
  attachments: [Attachment!]
  aiModel: String
  loras: [String!]
  workflow: String
  version: String
}

type Order @entity {
  id: Bytes!
  orderId: BigInt!
  market: MarketContract!
  buyer: Bytes!
  totalPayments: BigInt!
  orderStatus: BigInt!
  fulfillmentData: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  payments: [Payment!]
  parentId: BigInt
  parentAmount: BigInt
  childId: BigInt
  childAmount: BigInt
  templateId: BigInt
  templateAmount: BigInt
  parentContract: Bytes
  childContract: Bytes
  templateContract: Bytes
  isPhysical: Boolean!
  fulfillment: Fulfillment
}

type Payment @entity {
  id: Bytes!
  order: Order!
  fulfillerId: BigInt!
  amount: BigInt!
  recipient: Bytes!
  paymentType: BigInt!
}

type OrderReceipt @entity {
  id: Bytes!
  orderId: BigInt!
  buyer: Bytes!
  timestamp: BigInt!
  status: BigInt!
  params: PurchaseParams!
  breakdown: PaymentBreakdown!
}

type PurchaseParams @entity {
  id: Bytes!
  parentId: BigInt!
  parentAmount: BigInt!
  childId: BigInt!
  childAmount: BigInt!
  templateId: BigInt!
  templateAmount: BigInt!
  parentContract: Bytes!
  childContract: Bytes!
  templateContract: Bytes!
  isPhysical: Boolean!
  fulfillmentData: Bytes!
}

type PaymentBreakdown @entity {
  id: Bytes!
  totalPayments: BigInt!
  payments: [PaymentItem!]
}

type PaymentItem @entity {
  id: Bytes!
  fulfillerId: BigInt!
  amount: BigInt!
  recipient: Bytes!
  paymentType: BigInt!
}

type FulfillmentWorkflow @entity {
  id: Bytes!
  parent: Parent!
  digitalSteps: [FulfillmentStep!]
  physicalSteps: [FulfillmentStep!]
}

type FulfillmentStep @entity {
  id: Bytes!
  workflow: FulfillmentWorkflow!
  stepIndex: BigInt!
  fulfiller: Bytes!
  instructions: String!
  notes: String!
  subPerformers: [SubPerformer!]
  isPhysical: Boolean!
  completedAt: BigInt!
  isCompleted: Boolean!
}

type SubPerformer @entity {
  id: Bytes!
  step: FulfillmentStep!
  performer: Bytes!
  splitBasisPoints: BigInt!
}

type Fulfillment @entity {
  id: Bytes!
  orderId: BigInt!
  parent: Parent!
  currentStep: BigInt!
  createdAt: BigInt!
  lastUpdated: BigInt!
  order: Order!
}
